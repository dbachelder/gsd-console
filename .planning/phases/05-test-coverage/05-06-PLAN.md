---
phase: 05-test-coverage
plan: 06
type: execute
wave: 5
depends_on: [05-01]
files_modified:
  - test/hooks/useFileWatcher.test.ts
  - test/hooks/useChangeHighlight.test.ts
autonomous: true
must_haves:
  truths:
    - "useFileWatcher tests pass (watches directory, debounces changes)"
    - "useChangeHighlight tests pass (tracks changed files, highlights items)"
  artifacts:
    - path: test/hooks/useFileWatcher.test.ts
      provides: "File watcher hook tests with mocked fs.watch"
      min_lines: 80
    - path: test/hooks/useChangeHighlight.test.ts
      provides: "Change highlight hook tests"
      min_lines: 50
  key_links:
    - from: test/hooks/useFileWatcher.test.ts
      to: src/hooks/useFileWatcher.ts
      via: "component wrapper with vi.mock('fs')"
      pattern: "vi\\.mock\\(.*node:fs"
---

<objective>
Add test coverage for file watcher and change highlight hooks using memfs and vi.mock for fs.watch.

Purpose: These hooks enable real-time updates. useFileWatcher uses fs.watch which must be mocked. useChangeHighlight tracks changed files for visual indicators. Both are critical for live TUI updates.

Output: File watcher and change highlight hooks tested, debounce timing verified.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/phases/05-test-coverage/05-RESEARCH.md
@src/hooks/useFileWatcher.ts
@src/hooks/useChangeHighlight.ts
@.planning/phases/05-test-coverage/05-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Add useFileWatcher tests with mocked fs.watch</name>
  <files>test/hooks/useFileWatcher.test.ts</files>
  <action>
    Create test/hooks/useFileWatcher.test.ts:

    Follow Pattern 4 from 05-RESEARCH.md - mock fs.watch:

    ```typescript
    import { describe, expect, test, beforeEach, vi, useRef } from 'bun:test';
    import { render } from 'ink-testing-library';
    import { useFileWatcher } from '../../src/hooks/useFileWatcher.ts';

    // Mock fs.watch to simulate file change events without real filesystem
    vi.mock('node:fs', async () => {
      const actual = await vi.importActual('node:fs');
      return {
        ...actual,
        watch: vi.fn((path, options, callback) => {
          // Return mock watcher with close() method
          return {
            close: vi.fn(),
            on: vi.fn((event, handler) => {
              if (event === 'error') {
                (callback as any).errorHandler = handler;
              }
            }),
          };
        }),
      };
    });

    describe('useFileWatcher', () => {
      beforeEach(() => {
        vi.clearAllMocks();
      });

      test('emits changed files on watch event', async () => {
        const changedFilesRef = useRef<string[]>([]);

        const TestComponent = () => {
          const { changedFiles } = useFileWatcher({
            path: '.planning',
            debounceMs: 100,
          });
          changedFilesRef.current = changedFiles;
          return null;
        };

        render(<TestComponent />);

        // Get watch mock to trigger callbacks
        const watch = vi.mocked(require('node:fs').watch);
        const watchCallback = watch.mock.calls[0]?.[2];

        // Simulate file change event
        watchCallback?.('change', 'ROADMAP.md');

        // Wait for debounce (100ms + buffer)
        await new Promise(resolve => setTimeout(resolve, 150));

        expect(changedFilesRef.current).toContain('ROADMAP.md');
      });

      test('debounces rapid changes', async () => {
        const changedFilesRef = useRef<string[]>([]);

        const TestComponent = () => {
          const { changedFiles } = useFileWatcher({
            path: '.planning',
            debounceMs: 100,
          });
          changedFilesRef.current = changedFiles;
          return null;
        };

        render(<TestComponent />);

        const watch = vi.mocked(require('node:fs').watch);
        const watchCallback = watch.mock.calls[0]?.[2];

        // Trigger multiple rapid changes within debounce window
        watchCallback?.('change', 'file1.md');
        watchCallback?.('change', 'file2.md');
        watchCallback?.('change', 'file3.md');

        // Wait for debounce + processing
        await new Promise(resolve => setTimeout(resolve, 200));

        // Should only emit once with last changes
        expect(changedFilesRef.current.length).toBeGreaterThan(0);
      });

      // Add tests:
      // - Clears changedFiles after consuming
      // - Closes watcher on unmount
      // - Handles watch errors
    });
    ```

    Address Open Question 1 from 05-RESEARCH.md: Use setTimeout with explicit delay for debounce timing.
  </action>
  <verify>bun test test/hooks/useFileWatcher.test.ts</verify>
  <done>useFileWatcher tests pass (watch events, debounce, cleanup)</done>
</task>

<task type="auto">
  <name>Add useChangeHighlight tests</name>
  <files>test/hooks/useChangeHighlight.test.ts</files>
  <action>
    Create test/hooks/useChangeHighlight.test.ts:

    Test cases:
    - Adds files to highlight set when they change
    - Clears highlights after timeout (3 seconds default)
    - Returns highlight function for specific items
    - Tracks multiple changed files
    - Handles empty changedFiles array
    - Clears highlights on unmount (cleanup)

    Based on CLAUDE.md "useChangeHighlight.ts - Tracks recently changed items for visual highlighting".
    Use component wrapper pattern to verify highlight state updates.
  </action>
  <verify>bun test test/hooks/useChangeHighlight.test.ts</verify>
  <done>useChangeHighlight tests pass (adds/clears highlights, timeout)</done>
</task>

</tasks>

<verification>
Run `bun test test/hooks/useFileWatcher.test.ts test/hooks/useChangeHighlight.test.ts` - all tests must pass.
Run `bun test --coverage` - verify hooks have >= 70% coverage.
</verification>

<success_criteria>
- useFileWatcher tests cover watch events, debouncing, cleanup
- useChangeHighlight tests cover add/clear highlights, timeout handling
- fs.watch is properly mocked with vi.mock
- Debounce timing verified with setTimeout
- Hook coverage >= 70%
</success_criteria>

<output>
After completion, create `.planning/phases/05-test-coverage/05-06-SUMMARY.md`
</output>
