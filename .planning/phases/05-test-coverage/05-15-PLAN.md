---
phase: 05-test-coverage
plan: 15
type: execute
wave: 3
depends_on: [05-11]
files_modified: [test/hooks/useExternalEditor.test.tsx]
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Hook functions have test coverage where feasible"
    - "useExternalEditor hook has test coverage"
    - "11 out of 13 hooks tested (increased from 9 to 11)"
  artifacts:
    - path: "test/hooks/useExternalEditor.test.tsx"
      provides: "useExternalEditor hook tests with mocked fs and process"
      covers: "findPhaseDir, getEditableFiles, openInEditor, hook return"
  key_links:
    - from: "test/hooks/useExternalEditor.test.tsx"
      to: "src/hooks/useExternalEditor.ts"
      via: "vi.mock for fs and process modules"
      pattern: "vi.mock\\('node:fs'\\)|vi.mock\\('node:child_process'\\)"
---

<objective>
Add test coverage for useExternalEditor hook, increasing tested hooks from 10 to 11 of 13.

Purpose: useExternalEditor is currently untested. It performs filesystem operations and spawns external processes, requiring vi.mock for isolation.

Output: Comprehensive tests for useExternalEditor covering all functions and branches.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-test-coverage/05-VERIFICATION.md
@.planning/phases/05-test-coverage/05-02-SUMMARY.md
@src/hooks/useExternalEditor.ts
</context>

<tasks>

<task type="auto">
  <name>Set up mocks for fs and process modules</name>
  <files>test/hooks/useExternalEditor.test.tsx</files>
  <action>
    Create test file with vi.mock for node:fs, node:child_process, and node:path modules.

    Pattern from 05-06-SUMMARY (useFileWatcher tests):
    ```tsx
    import { beforeEach, describe, expect, test, vi } from 'bun:test';
    import { render } from 'ink-testing-library';
    import { useExternalEditor } from '../../src/hooks/useExternalEditor.ts';

    // Mock fs operations
    vi.mock('node:fs', () => ({
      existsSync: vi.fn(),
      readdirSync: vi.fn(),
    }));

    // Mock process operations
    vi.mock('node:child_process', () => ({
      spawnSync: vi.fn(),
    }));

    // Mock path operations (use real implementation for now)
    vi.mock('node:path', async (importOriginal) => {
      const mod = await importOriginal<typeof import('node:path')>();
      return mod;
    });

    // Get mocked modules
    import { existsSync, readdirSync } from 'node:fs';
    import { spawnSync } from 'node:child_process';

    // Clear mocks before each test
    beforeEach(() => {
      vi.clearAllMocks();
    });

    describe('useExternalEditor', () => {
      // Test cases will go here
    });
    ```

    Mock setup allows control of filesystem and process behavior without real operations.
  </action>
  <verify>grep "vi.mock" test/hooks/useExternalEditor.test.tsx</verify>
  <done>Mocks set up for fs, process, path modules</done>
</task>

<task type="auto">
  <name>Test findPhaseDir function</name>
  <files>test/hooks/useExternalEditor.test.tsx</files>
  <action>
    Add tests for findPhaseDir helper function (lines 25-42 in useExternalEditor.ts).

    Function logic:
    - Takes planningDir and phaseNumber
    - Returns phase directory path like ".planning/phases/01-core-tui"
    - Pads phase number to 2 digits (1 â†’ "01")
    - Looks for directory starting with "01-", "02-", etc.
    - Returns null if phases directory doesn't exist

    ```tsx
    describe('findPhaseDir', () => {
      test('finds phase directory with padded number', () => {
        // Mock phases directory structure
        (readdirSync as ReturnType<typeof vi.fn>).mockReturnValue([
          { isDirectory: () => true, name: '01-core-tui' },
          { isDirectory: () => true, name: '02-real-time-updates' },
          { isDirectory: () => false, name: 'README.md' },
        ]);

        // Mock existsSync to return true for phases dir
        (existsSync as ReturnType<typeof vi.fn>).mockReturnValue(true);

        // Import function (private, test via useExternalEditor behavior)
        const { files } = useExternalEditor({
          activeTab: 'phase',
          selectedPhase: 1,
          planningDir: '.planning',
        });

        // Should find "01-core-tui" for phase 1
        expect(files.length).toBeGreaterThan(0);
        expect(files[0]).toContain('01');
      });

      test('returns null when phases directory does not exist', () => {
        (existsSync as ReturnType<typeof vi.fn>).mockReturnValue(false);

        const { files } = useExternalEditor({
          activeTab: 'phase',
          selectedPhase: 1,
          planningDir: '.planning',
        });

        expect(files).toEqual([]);
      });

      test('handles phase 10+ (double digit numbers)', () => {
        (existsSync as ReturnType<typeof vi.fn>).mockReturnValue(true);
        (readdirSync as ReturnType<typeof vi.fn>).mockReturnValue([
          { isDirectory: () => true, name: '10-test-phase' },
        ]);

        const { files } = useExternalEditor({
          activeTab: 'phase',
          selectedPhase: 10,
          planningDir: '.planning',
        });

        expect(files.length).toBeGreaterThan(0);
        expect(files[0]).toContain('10-');
      });

      test('ignores directories not matching phase number', () => {
        (existsSync as ReturnType<typeof vi.fn>).mockReturnValue(true);
        (readdirSync as ReturnType<typeof vi.fn>).mockReturnValue([
          { isDirectory: () => true, name: '01-core-tui' },
          { isDirectory: () => true, name: '02-wrong-phase' },
          { isDirectory: () => true, name: 'other-directory' },
        ]);

        const { files } = useExternalEditor({
          activeTab: 'phase',
          selectedPhase: 1,
          planningDir: '.planning',
        });

        // Should only find phase 1 directory
        expect(files.length).toBeGreaterThan(0);
        expect(files.every(f => f.includes('01'))).toBe(true);
      });
    });
    ```

    Note: findPhaseDir is a private function, tested indirectly via useExternalEditor behavior.
  </action>
  <verify>bun test test/hooks/useExternalEditor.test.tsx -t "findPhaseDir"</verify>
  <done>findPhaseDir behavior tested through useExternalEditor</done>
</task>

<task type="auto">
  <name>Test getEditableFiles for each tab context</name>
  <files>test/hooks/useExternalEditor.test.tsx</files>
  <action>
    Add tests for getEditableFiles function handling different activeTab values (lines 48-165).

    Four branches: roadmap, phase, todos, background

    ```tsx
    describe('getEditableFiles', () => {
      test('roadmap tab with phase selected returns phase files + ROADMAP', () => {
        (existsSync as ReturnType<typeof vi.fn>).mockImplementation((path) => {
          // Mock ROADMAP.md and phase files existing
          return typeof path === 'string' && (path.includes('ROADMAP') || path.includes('01-'));
        });

        (readdirSync as ReturnType<typeof vi.fn>).mockReturnValue([
          '01-01-PLAN.md',
          '01-CONTEXT.md',
          'SUMMARY.md',
        ]);

        const { files } = useExternalEditor({
          activeTab: 'roadmap',
          selectedPhase: 1,
          planningDir: '.planning',
        });

        // Should include plan files, context files, and ROADMAP
        expect(files.length).toBeGreaterThan(0);
        expect(files.some(f => f.includes('ROADMAP.md'))).toBe(true);
        expect(files.some(f => f.includes('01-'))).toBe(true);
      });

      test('roadmap tab without phase returns only ROADMAP', () => {
        (existsSync as ReturnType<typeof vi.fn>).mockImplementation((path) => {
          return typeof path === 'string' && path.includes('ROADMAP');
        });

        const { files } = useExternalEditor({
          activeTab: 'roadmap',
          selectedPhase: undefined,
          planningDir: '.planning',
        });

        expect(files).toEqual([expect.stringContaining('ROADMAP.md')]);
      });

      test('phase tab returns phase files only', () => {
        (existsSync as ReturnType<typeof vi.fn>).mockReturnValue(true);
        (readdirSync as ReturnType<typeof vi.fn>).mockReturnValue([
          '01-01-PLAN.md',
          '01-CONTEXT.md',
          'README.md',
        ]);

        const { files } = useExternalEditor({
          activeTab: 'phase',
          selectedPhase: 1,
          planningDir: '.planning',
        });

        // Should include phase files (01-*.md, CONTEXT.md, PLAN.md, etc.)
        expect(files.length).toBeGreaterThan(0);
        expect(files.every(f => f.includes('01') || f.includes('CONTEXT') || f.includes('PLAN'))).toBe(true);
      });

      test('todos tab returns todo file path if exists', () => {
        (existsSync as ReturnType<typeof vi.fn>).mockImplementation((path) => {
          return typeof path === 'string' && path.includes('todos/pending') && path.includes('test-task.md');
        });

        const { files } = useExternalEditor({
          activeTab: 'todos',
          selectedTodo: 'pending-test-task.md',
          planningDir: '.planning',
        });

        expect(files).toEqual([expect.stringContaining('todos/pending/test-task.md')]);
      });

      test('background tab returns empty array', () => {
        const { files } = useExternalEditor({
          activeTab: 'background',
          planningDir: '.planning',
        });

        expect(files).toEqual([]);
      });

      test('handles missing phase directory gracefully', () => {
        (existsSync as ReturnType<typeof vi.fn>).mockReturnValue(false);

        const { files } = useExternalEditor({
          activeTab: 'phase',
          selectedPhase: 99, // Non-existent phase
          planningDir: '.planning',
        });

        expect(files).toEqual([]);
      });
    });
    ```

    Test all tab branches and edge cases.
  </action>
  <verify>bun test test/hooks/useExternalEditor.test.tsx -t "getEditableFiles"</verify>
  <done>All tab contexts tested, edge cases handled</done>
</task>

<task type="auto">
  <name>Test openInEditor and useExternalEditor return values</name>
  <files>test/hooks/useExternalEditor.test.tsx</files>
  <action>
    Add tests for openInEditor function and hook return values (files, open, needsPicker).

    ```tsx
    describe('openInEditor and hook returns', () => {
      test('openInEditor uses EDITOR env var', () => {
        const originalEditor = process.env.EDITOR;
        process.env.EDITOR = 'vim';

        (spawnSync as ReturnType<typeof vi.fn>).mockReturnValue({ status: 0 });

        // Test openInEditor via hook open function
        const { open } = useExternalEditor({
          activeTab: 'roadmap',
          selectedPhase: 1,
          planningDir: '.planning',
        });

        // Setup files for opening
        (existsSync as ReturnType<typeof vi.fn>).mockReturnValue(true);
        (readdirSync as ReturnType<typeof vi.fn>).mockReturnValue(['ROADMAP.md']);

        const { open: openFn } = useExternalEditor({
          activeTab: 'roadmap',
          planningDir: '.planning',
        });

        const result = openFn();

        expect(spawnSync).toHaveBeenCalledWith(
          'vim',
          [expect.any(String)],
          { stdio: 'inherit', env: process.env }
        );
        expect(result).toBe(true);

        process.env.EDITOR = originalEditor;
      });

      test('openInEditor falls back to VISUAL if EDITOR not set', () => {
        const originalEditor = process.env.EDITOR;
        const originalVisual = process.env.VISUAL;
        delete process.env.EDITOR;
        process.env.VISUAL = 'nano';

        (spawnSync as ReturnType<typeof vi.fn>).mockReturnValue({ status: 0 });

        const { open } = useExternalEditor({
          activeTab: 'roadmap',
          planningDir: '.planning',
        });

        (existsSync as ReturnType<typeof vi.fn>).mockReturnValue(true);

        const result = open('test-file.md');

        expect(spawnSync).toHaveBeenCalledWith('nano', expect.any(Array), expect.any(Object));

        process.env.EDITOR = originalEditor;
        process.env.VISUAL = originalVisual;
      });

      test('openInEditor handles editor errors gracefully', () => {
        (spawnSync as ReturnType<typeof vi.fn>).mockReturnValue({ status: 1 });

        const { open } = useExternalEditor({
          activeTab: 'roadmap',
          planningDir: '.planning',
        });

        (existsSync as ReturnType<typeof vi.fn>).mockReturnValue(true);

        const result = open('test-file.md');

        expect(result).toBe(false);
      });

      test('hook returns needsPicker true when multiple files', () => {
        (existsSync as ReturnType<typeof vi.fn>).mockReturnValue(true);
        (readdirSync as ReturnType<typeof vi.fn>).mockReturnValue([
          '01-01-PLAN.md',
          '01-02-PLAN.md',
          '01-CONTEXT.md',
        ]);

        const { needsPicker } = useExternalEditor({
          activeTab: 'phase',
          selectedPhase: 1,
          planningDir: '.planning',
        });

        expect(needsPicker).toBe(true);
      });

      test('hook returns needsPicker false when single or no files', () => {
        (existsSync as ReturnType<typeof vi.fn>).mockReturnValue(true);
        (readdirSync as ReturnType<typeof vi.fn>).mockReturnValue(['01-01-PLAN.md']);

        const { needsPicker } = useExternalEditor({
          activeTab: 'phase',
          selectedPhase: 1,
          planningDir: '.planning',
        });

        expect(needsPicker).toBe(false);
      });
    });
    ```

    Test environment variable handling and error cases.
  </action>
  <verify>bun test test/hooks/useExternalEditor.test.tsx -t "openInEditor"</verify>
  <done>openInEditor and hook return values tested</done>
</task>

<task type="auto">
  <name>Verify useExternalEditor coverage and run all hook tests</name>
  <files></files>
  <action>
    Run useExternalEditor tests with coverage:

    ```bash
    bun test test/hooks/useExternalEditor.test.tsx --coverage
    ```

    Check coverage report for src/hooks/useExternalEditor.ts:
    1. Verify line coverage >= 75%
    2. All functions covered: findPhaseDir, getEditableFiles, openInEditor, useExternalEditor
    3. All tab branches tested (roadmap, phase, todos, background)
    4. Error paths tested

    Then run all hook tests:
    ```bash
    bun test test/hooks/
    ```

    Expected outcome:
    - useExternalEditor tests pass (12-15 tests)
    - All other hook tests still pass
    - Total hook tests: 11 of 13 hooks now tested (up from 10)

    If coverage < 75%:
    1. Identify uncovered lines
    2. Check if they're edge cases or error paths
    3. Add specific test if coverage gap is significant
  </action>
  <verify>bun test test/hooks/useExternalEditor.test.tsx --coverage 2>&1 | grep -A 5 "useExternalEditor.ts"</verify>
  <done>useExternalEditor.ts coverage >= 75%, all hook tests pass</done>
</task>

</tasks>

<verification>
After completion, verify:
1. bun test test/hooks/useExternalEditor.test.tsx shows all tests passing
2. Coverage report shows useExternalEditor.ts at 75%+ line coverage
3. All hook tests (11 of 13 hooks) still pass after new tests
4. findPhaseDir, getEditableFiles, openInEditor, hook return all tested
</verification>

<success_criteria>
- useExternalEditor hook has comprehensive test coverage (75%+ lines)
- Tests cover findPhaseDir, getEditableFiles, openInEditor, hook return
- All tab contexts tested (roadmap, phase, todos, background)
- Editor environment variables and error handling tested
- 11 of 13 hooks now have test coverage (up from 10)
</success_criteria>

<output>
After completion, create `.planning/phases/05-test-coverage/05-15-SUMMARY.md`
</output>
