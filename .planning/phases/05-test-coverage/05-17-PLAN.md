---
phase: 05-test-coverage
plan: 17
type: execute
wave: 4
depends_on: [05-11]
files_modified: [test/hooks/useSessionActivity.test.tsx]
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Hook functions have test coverage where feasible"
    - "useSessionActivity hook has test coverage"
    - "13 out of 13 hooks tested (increased from 12 to 13)"
  artifacts:
    - path: "test/hooks/useSessionActivity.test.tsx"
      provides: "useSessionActivity hook tests with mocked session activity"
      covers: "Initial state, activity updates, cleanup on unmount"
  key_links:
    - from: "test/hooks/useSessionActivity.test.tsx"
      to: "src/hooks/useSessionActivity.ts"
      via: "vi.mock for sessionActivity module"
      pattern: "vi.mock\\('\\.\\.\\.\\.\\\\/lib/sessionActivity\\.ts'\\)"
---

<objective>
Add test coverage for useSessionActivity hook, completing test coverage for all 13 hooks.

Purpose: useSessionActivity is the final untested hook. It tracks OpenCode session activity using lib/sessionActivity functions.

Output: Comprehensive tests for useSessionActivity covering initialization, updates, and cleanup.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-test-coverage/05-VERIFICATION.md
@.planning/phases/05-test-coverage/05-06-SUMMARY.md
@src/hooks/useSessionActivity.ts
@src/lib/sessionActivity.ts
</context>

<tasks>

<task type="auto">
  <name>Set up mocks for sessionActivity module</name>
  <files>test/hooks/useSessionActivity.test.tsx</files>
  <action>
    Create test file with vi.mock for sessionActivity module.

    Pattern from 05-06-SUMMARY (useChangeHighlight tests with vi.mock):
    ```tsx
    import { beforeEach, describe, expect, test, vi } from 'bun:test';
    import { render } from 'ink-testing-library';
    import { useSessionActivity } from '../../src/hooks/useSessionActivity.ts';

    // Mock sessionActivity functions
    vi.mock('../../src/lib/sessionActivity.ts', () => ({
      getActiveSession: vi.fn(),
      monitorSessionActivity: vi.fn(),
    }));

    // Import mocked modules
    import {
      getActiveSession,
      monitorSessionActivity,
      type SessionActivity,
    } from '../../src/lib/sessionActivity.ts';

    // Clear mocks before each test
    beforeEach(() => {
      vi.clearAllMocks();
    });

    describe('useSessionActivity', () => {
      // Test cases will go here
    });
    ```

    Mock setup allows control of session activity behavior without real OpenCode connection.
  </action>
  <verify>grep "vi.mock" test/hooks/useSessionActivity.test.tsx</verify>
  <done>Mock set up for sessionActivity module</done>
</task>

<task type="auto">
  <name>Test initial state and session loading</name>
  <files>test/hooks/useSessionActivity.test.tsx</files>
  <action>
    Add tests for initial state (null) and loading active session on mount.

    Hook behavior on mount:
    - Starts with null activity
    - Calls getActiveSession() on mount
    - Updates state with active session data

    ```tsx
    describe('initialization', () => {
      test('starts with null activity', () => {
        let capturedActivity: SessionActivity | null = null;

        const TestComponent = () => {
          const activity = useSessionActivity();
          capturedActivity = activity;
          return null;
        };

        render(<TestComponent />);

        // Initial state should be null
        expect(capturedActivity).toBeNull();
      });

      test('loads active session on mount', async () => {
        const mockActivity: SessionActivity = {
          sessionId: 'session-123',
          title: 'Phase 05: Test Coverage',
          isActive: true,
          currentActivity: 'gsd-plan-checker: running',
          lastUpdated: Date.now(),
        };

        (getActiveSession as ReturnType<typeof vi.fn>).mockResolvedValue(mockActivity);

        let capturedActivity: SessionActivity | null = null;

        const TestComponent = () => {
          const activity = useSessionActivity();
          capturedActivity = activity;
          return null;
        };

        render(<TestComponent />);

        // Wait for async getActiveSession to resolve
        await new Promise(resolve => setTimeout(resolve, 100));

        // Should have loaded session data
        expect(capturedActivity).not.toBeNull();
        expect(capturedActivity?.sessionId).toBe('session-123');
        expect(capturedActivity?.isActive).toBe(true);
        expect(capturedActivity?.currentActivity).toBe('gsd-plan-checker: running');
      });

      test('handles no active session', async () => {
        (getActiveSession as ReturnType<typeof vi.fn>).mockResolvedValue(null);

        let capturedActivity: SessionActivity | null = null;

        const TestComponent = () => {
          const activity = useSessionActivity();
          capturedActivity = activity;
          return null;
        };

        render(<TestComponent />);

        await new Promise(resolve => setTimeout(resolve, 100));

        // Should remain null if no active session
        expect(capturedActivity).toBeNull();
      });

      test('identifies inactive sessions (updated > 60s ago)', async () => {
        const inactiveActivity: SessionActivity = {
          sessionId: 'session-123',
          title: 'Old session',
          isActive: false,
          currentActivity: 'idle',
          lastUpdated: Date.now() - 120000, // 2 minutes ago
        };

        (getActiveSession as ReturnType<typeof vi.fn>).mockResolvedValue(inactiveActivity);

        let capturedActivity: SessionActivity | null = null;

        const TestComponent = () => {
          const activity = useSessionActivity();
          capturedActivity = activity;
          return null;
        };

        render(<TestComponent />);

        await new Promise(resolve => setTimeout(resolve, 100));

        // Should capture inactive session correctly
        expect(capturedActivity?.isActive).toBe(false);
        expect(capturedActivity?.currentActivity).toBe('idle');
      });
    });
    ```

    Test async loading and session state capture.
  </action>
  <verify>bun test test/hooks/useSessionActivity.test.tsx -t "initialization"</verify>
  <done>Initial state and session loading tested</done>
</task>

<task type="auto">
  <name>Test activity monitoring and updates</name>
  <files>test/hooks/useSessionActivity.test.tsx</files>
  <action>
    Add tests for monitorSessionActivity callback and real-time updates.

    Hook behavior:
    - Calls monitorSessionActivity(callback) on mount
    - Updates state when callback receives new activity
    - Returns cleanup function on unmount

    ```tsx
    describe('activity monitoring', () => {
      test('registers callback with monitorSessionActivity', async () => {
        (getActiveSession as ReturnType<typeof vi.fn>).mockResolvedValue(null);

        let mockCallback: ((activity: SessionActivity) => void) | null = null;

        (monitorSessionActivity as ReturnType<typeof vi.fn>).mockImplementation((callback) => {
          mockCallback = callback;
          return () => {}; // Cleanup function
        });

        const TestComponent = () => {
          useSessionActivity();
          return null;
        };

        render(<TestComponent />);

        await new Promise(resolve => setTimeout(resolve, 100));

        // Should have registered callback
        expect(monitorSessionActivity).toHaveBeenCalled();
        expect(mockCallback).not.toBeNull();
      });

      test('updates state when callback receives new activity', async () => {
        (getActiveSession as ReturnType<typeof vi.fn>).mockResolvedValue(null);

        let capturedActivity: SessionActivity | null = null;
        let mockCallback: ((activity: SessionActivity) => void) | null = null;

        (monitorSessionActivity as ReturnType<typeof vi.fn>).mockImplementation((callback) => {
          mockCallback = callback;
          return () => {};
        });

        const TestComponent = () => {
          const activity = useSessionActivity();
          capturedActivity = activity;
          return null;
        };

        render(<TestComponent />);

        await new Promise(resolve => setTimeout(resolve, 100));

        // Simulate new activity from callback
        const newActivity: SessionActivity = {
          sessionId: 'session-456',
          title: 'New session',
          isActive: true,
          currentActivity: 'gsd-execute: running',
          lastUpdated: Date.now(),
        };

        if (mockCallback) {
          mockCallback(newActivity);
        }

        // Wait for state update
        await new Promise(resolve => setTimeout(resolve, 50));

        // Should have updated activity
        expect(capturedActivity).not.toBeNull();
        expect(capturedActivity?.sessionId).toBe('session-456');
        expect(capturedActivity?.currentActivity).toBe('gsd-execute: running');
      });

      test('handles session becoming inactive', async () => {
        const initialActivity: SessionActivity = {
          sessionId: 'session-123',
          title: 'Active session',
          isActive: true,
          currentActivity: 'running',
          lastUpdated: Date.now(),
        };

        (getActiveSession as ReturnType<typeof vi.fn>).mockResolvedValue(initialActivity);

        let capturedActivity: SessionActivity | null = initialActivity;
        let mockCallback: ((activity: SessionActivity) => void) | null = null;

        (monitorSessionActivity as ReturnType<typeof vi.fn>).mockImplementation((callback) => {
          mockCallback = callback;
          return () => {};
        });

        const TestComponent = () => {
          const activity = useSessionActivity();
          capturedActivity = activity;
          return null;
        };

        render(<TestComponent />);

        await new Promise(resolve => setTimeout(resolve, 100));

        // Simulate session becoming inactive
        const inactiveActivity: SessionActivity = {
          ...initialActivity,
          isActive: false,
          lastUpdated: Date.now() - 120000,
        };

        if (mockCallback) {
          mockCallback(inactiveActivity);
        }

        await new Promise(resolve => setTimeout(resolve, 50));

        expect(capturedActivity?.isActive).toBe(false);
      });
    });
    ```

    Test monitoring callback and state updates.
  </action>
  <verify>bun test test/hooks/useSessionActivity.test.tsx -t "monitoring"</verify>
  <done>Activity monitoring and state updates tested</done>
</task>

<task type="auto">
  <name>Test cleanup on unmount and verify all hook coverage</name>
  <files></files>
  <action>
    Add test for cleanup function returned by monitorSessionActivity.

    ```tsx
    describe('cleanup', () => {
      test('calls cleanup function on unmount', async () => {
        (getActiveSession as ReturnType<typeof vi.fn>).mockResolvedValue(null);

        let cleanupCalled = false;

        const mockCleanup = () => {
          cleanupCalled = true;
        };

        (monitorSessionActivity as ReturnType<typeof vi.fn>).mockReturnValue(mockCleanup);

        const TestComponent = () => {
          useSessionActivity();
          return null;
        };

        const { unmount } = render(<TestComponent />);

        await new Promise(resolve => setTimeout(resolve, 100));

        // Unmount component
        unmount();

        // Cleanup should have been called
        expect(cleanupCalled).toBe(true);
      });
    });
    ```

    Then verify useSessionActivity coverage and run all hook tests:

    ```bash
    bun test test/hooks/useSessionActivity.test.tsx --coverage
    ```

    Check coverage report for src/hooks/useSessionActivity.ts:
    1. Verify line coverage >= 75% (simple hook, should be higher)
    2. All code paths covered: mount, update, unmount

    Then run all hook tests:
    ```bash
    bun test test/hooks/
    ```

    Expected outcome:
    - useSessionActivity tests pass (6-8 tests)
    - All other hook tests still pass
    - **Total: 13 of 13 hooks tested** (100% coverage)
  </action>
  <verify>bun test test/hooks/useSessionActivity.test.tsx --coverage 2>&1 | grep -A 5 "useSessionActivity.ts"</verify>
  <done>useSessionActivity.ts coverage >= 75%, all 13 hooks tested</done>
</task>

</tasks>

<verification>
After completion, verify:
1. bun test test/hooks/useSessionActivity.test.tsx shows all tests passing
2. Coverage report shows useSessionActivity.ts at 75%+ line coverage
3. All hook tests (13 of 13 hooks) still pass after new tests
4. Initial state, session loading, monitoring, and cleanup all tested
</verification>

<success_criteria>
- useSessionActivity hook has comprehensive test coverage (75%+ lines)
- Tests cover initialization, activity loading, monitoring callbacks, cleanup
- Active vs inactive session detection tested
- **13 of 13 hooks now have test coverage (100% of hooks tested)**
</success_criteria>

<output>
After completion, create `.planning/phases/05-test-coverage/05-17-SUMMARY.md`
</output>
