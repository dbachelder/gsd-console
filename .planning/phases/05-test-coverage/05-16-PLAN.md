---
phase: 05-test-coverage
plan: 16
type: execute
wave: 3
depends_on: [05-11, 05-12]
files_modified: [test/hooks/useGsdData.test.tsx]
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Hook functions have test coverage where feasible"
    - "useGsdData hook has test coverage"
    - "12 out of 13 hooks tested (increased from 11 to 12)"
  artifacts:
    - path: "test/hooks/useGsdData.test.tsx"
      provides: "useGsdData hook tests with mocked parser"
      covers: "Loading state, error handling, data parsing, refresh trigger"
  key_links:
    - from: "test/hooks/useGsdData.test.tsx"
      to: "src/hooks/useGsdData.ts"
      via: "vi.mock for parser module"
      pattern: "vi.mock\\('\\.\\.\\.\\.\\\\/lib/parser\\.ts'\\)"
---

<objective>
Add test coverage for useGsdData hook, increasing tested hooks from 11 to 12 of 13.

Purpose: useGsdData is currently untested. It loads and parses GSD planning documents, requiring vi.mock for parser functions.

Output: Comprehensive tests for useGsdData covering data loading, error handling, and refresh triggers.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-test-coverage/05-VERIFICATION.md
@.planning/phases/05-test-coverage/05-02-SUMMARY.md
@src/hooks/useGsdData.ts
@src/lib/parser.ts
</context>

<tasks>

<task type="auto">
  <name>Set up mocks for parser module and fs</name>
  <files>test/hooks/useGsdData.test.tsx</files>
  <action>
    Create test file with vi.mock for parser module and fs operations.

    Pattern from 05-02-SUMMARY (parser tests with mocked fs):
    ```tsx
    import { beforeEach, describe, expect, test, vi } from 'bun:test';
    import { render } from 'ink-testing-library';
    import { useGsdData } from '../../src/hooks/useGsdData.ts';

    // Mock parser functions
    vi.mock('../../src/lib/parser.ts', () => ({
      parseRoadmap: vi.fn(),
      parseState: vi.fn(),
      parseTodos: vi.fn(),
      readPlanningFile: vi.fn(),
    }));

    // Mock fs operations (for directory existence check)
    vi.mock('node:fs', () => ({
      existsSync: vi.fn(),
    }));

    // Import mocked modules
    import { parseRoadmap, parseState, parseTodos, readPlanningFile } from '../../src/lib/parser.ts';
    import { existsSync } from 'node:fs';

    // Clear mocks before each test
    beforeEach(() => {
      vi.clearAllMocks();
    });

    describe('useGsdData', () => {
      // Test cases will go here
    });
    ```

    Mock setup allows control of parser behavior and filesystem checks.
  </action>
  <verify>grep "vi.mock" test/hooks/useGsdData.test.tsx</verify>
  <done>Mocks set up for parser module and fs</done>
</task>

<task type="auto">
  <name>Test initial loading state and successful data load</name>
  <files>test/hooks/useGsdData.test.tsx</files>
  <action>
    Add tests for initial state (loading: true) and successful data loading.

    Hook behavior on mount:
    - Starts with loading: true
    - Calls parseRoadmap, parseState, parseTodos
    - Sets loading: false on completion
    - Populates phases, todos, state, changedFiles

    ```tsx
    describe('initialization and loading', () => {
      test('starts with loading state true', () => {
        let capturedLoading = false;
        let capturedData: any = null;

        const TestComponent = () => {
          const data = useGsdData('.planning');
          capturedLoading = data.loading;
          capturedData = data;
          return null;
        };

        render(<TestComponent />);

        // Initial state should have loading: true
        expect(capturedLoading).toBe(true);
      });

      test('loads and parses planning documents successfully', async () => {
        (existsSync as ReturnType<typeof vi.fn>).mockReturnValue(true);

        // Mock parser functions to return test data
        (parseRoadmap as ReturnType<typeof vi.fn>).mockReturnValue([
          { number: 1, name: 'Core TUI', status: 'complete' },
        ]);

        (parseState as ReturnType<typeof vi.fn>).mockReturnValue({
          projectName: 'Test Project',
          coreValue: 'Test value',
          currentPhase: 1,
          totalPhases: 1,
        });

        (parseTodos as ReturnType<typeof vi.fn>).mockReturnValue([
          { id: 'pending-1.md', text: 'Test todo', status: 'pending' },
        ]);

        (readPlanningFile as ReturnType<typeof vi.fn>).mockReturnValue({
          content: 'mock content',
        });

        let capturedData: any = null;

        const TestComponent = () => {
          const data = useGsdData('.planning');
          capturedData = data;
          return null;
        };

        render(<TestComponent />);

        // Wait for async loading to complete
        await new Promise(resolve => setTimeout(resolve, 100));

        // Should have loaded data
        expect(capturedData.loading).toBe(false);
        expect(capturedData.phases).toHaveLength(1);
        expect(capturedData.todos).toHaveLength(1);
        expect(capturedData.state?.projectName).toBe('Test Project');
        expect(capturedData.error).toBeNull();
      });

      test('calculates progress percent from completed phases', async () => {
        (existsSync as ReturnType<typeof vi.fn>).mockReturnValue(true);
        (readPlanningFile as ReturnType<typeof vi.fn>).mockReturnValue({
          content: 'mock',
        });

        // 2 phases, 1 complete = 50% progress
        (parseRoadmap as ReturnType<typeof vi.fn>).mockReturnValue([
          { number: 1, name: 'Phase 1', status: 'complete' },
          { number: 2, name: 'Phase 2', status: 'in-progress' },
        ]);

        (parseState as ReturnType<typeof vi.fn>).mockReturnValue({
          projectName: 'Test',
          currentPhase: 1,
          totalPhases: 0, // Will be overwritten
        });

        (parseTodos as ReturnType<typeof vi.fn>).mockReturnValue([]);

        let capturedProgress = 0;

        const TestComponent = () => {
          const data = useGsdData('.planning');
          capturedProgress = data.state?.progressPercent ?? 0;
          return null;
        };

        render(<TestComponent />);

        await new Promise(resolve => setTimeout(resolve, 100));

        // 1 of 2 phases complete = 50%
        expect(capturedProgress).toBe(50);
      });
    });
    ```

    Test async loading and state updates.
  </action>
  <verify>bun test test/hooks/useGsdData.test.tsx -t "initialization"</verify>
  <done>Loading state and successful data load tested</done>
</task>

<task type="auto">
  <name>Test error handling and missing directory</name>
  <files>test/hooks/useGsdData.test.tsx</files>
  <action>
    Add tests for error cases: missing planning directory, parser errors.

    ```tsx
    describe('error handling', () => {
      test('handles missing planning directory', async () => {
        // Mock directory not existing
        (existsSync as ReturnType<typeof vi.fn>).mockReturnValue(false);

        let capturedError: Error | null = null;

        const TestComponent = () => {
          const data = useGsdData('.planning');
          capturedError = data.error;
          return null;
        };

        render(<TestComponent />);

        await new Promise(resolve => setTimeout(resolve, 100));

        // Should have error about missing directory
        expect(capturedError).not.toBeNull();
        expect(capturedError?.message).toContain('Planning directory not found');
        expect(capturedData.loading).toBe(false);
      });

      test('handles parser errors gracefully', async () => {
        (existsSync as ReturnType<typeof vi.fn>).mockReturnValue(true);
        (readPlanningFile as ReturnType<typeof vi.fn>).mockReturnValue({
          content: 'mock',
        });

        // Mock parseRoadmap to throw error
        (parseRoadmap as ReturnType<typeof vi.fn>).mockImplementation(() => {
          throw new Error('Parse error');
        });

        let capturedError: Error | null = null;
        let capturedLoading = true;

        const TestComponent = () => {
          const data = useGsdData('.planning');
          capturedError = data.error;
          capturedLoading = data.loading;
          return null;
        };

        render(<TestComponent />);

        await new Promise(resolve => setTimeout(resolve, 100));

        // Should catch and store error
        expect(capturedError).not.toBeNull();
        expect(capturedError?.message).toContain('Failed to load planning data');
        expect(capturedLoading).toBe(false);
      });

      test('enhances state with PROJECT.md data', async () => {
        (existsSync as ReturnType<typeof vi.fn>).mockReturnValue(true);
        (readPlanningFile as ReturnType<typeof vi.fn>).mockImplementation((path) => {
          if (path.includes('PROJECT.md')) {
            return {
              content: '# My Project\n**Core Value:** Test Value',
            };
          }
          return { content: 'mock' };
        });

        (parseRoadmap as ReturnType<typeof vi.fn>).mockReturnValue([]);
        (parseState as ReturnType<typeof vi.fn>).mockReturnValue({
          projectName: 'Default',
          coreValue: '',
        });
        (parseTodos as ReturnType<typeof vi.fn>).mockReturnValue([]);

        let capturedProjectName = '';
        let capturedCoreValue = '';

        const TestComponent = () => {
          const data = useGsdData('.planning');
          capturedProjectName = data.state?.projectName ?? '';
          capturedCoreValue = data.state?.coreValue ?? '';
          return null;
        };

        render(<TestComponent />);

        await new Promise(resolve => setTimeout(resolve, 100));

        // Should extract project name and core value from PROJECT.md
        expect(capturedProjectName).toBe('My Project');
        expect(capturedCoreValue).toBe('Test Value');
      });
    });
    ```

    Test error paths and PROJECT.md parsing.
  </action>
  <verify>bun test test/hooks/useGsdData.test.tsx -t "error"</verify>
  <done>Error handling tested, missing directory and parser errors covered</done>
</task>

<task type="auto">
  <name>Test refresh trigger and changedFiles handling</name>
  <files>test/hooks/useGsdData.test.tsx</files>
  <action>
    Add tests for refreshTrigger parameter and changedFiles array behavior.

    Hook behavior:
    - refreshTrigger changes cause data reload
    - changedFiles passed to result (from useFileWatcher)
    - Uses ref pattern to avoid render loop with changedFiles

    ```tsx
    describe('refresh and changed files', () => {
      test('stores changedFiles in result', async () => {
        (existsSync as ReturnType<typeof vi.fn>).mockReturnValue(true);
        (readPlanningFile as ReturnType<typeof vi.fn>).mockReturnValue({ content: 'mock' });

        (parseRoadmap as ReturnType<typeof vi.fn>).mockReturnValue([]);
        (parseState as ReturnType<typeof vi.fn>).mockReturnValue({
          projectName: 'Test',
        });
        (parseTodos as ReturnType<typeof vi.fn>).mockReturnValue([]);

        let capturedChangedFiles: string[] = [];

        const TestComponent = () => {
          const data = useGsdData('.planning', undefined, [
            '.planning/ROADMAP.md',
            '.planning/STATE.md',
          ]);
          capturedChangedFiles = data.changedFiles;
          return null;
        };

        render(<TestComponent />);

        await new Promise(resolve => setTimeout(resolve, 100));

        // Should store changed files from parameter
        expect(capturedChangedFiles).toEqual([
          '.planning/ROADMAP.md',
          '.planning/STATE.md',
        ]);
      });

      test('reloads data when refreshTrigger changes', async () => {
        (existsSync as ReturnType<typeof vi.fn>).mockReturnValue(true);
        (readPlanningFile as ReturnType<typeof vi.fn>).mockReturnValue({ content: 'mock' });

        let parseCount = 0;
        (parseRoadmap as ReturnType<typeof vi.fn>).mockImplementation(() => {
          parseCount++;
          return [];
        });
        (parseState as ReturnType<typeof vi.fn>).mockReturnValue({ projectName: 'Test' });
        (parseTodos as ReturnType<typeof vi.fn>).mockReturnValue([]);

        const TestComponent = () => {
          useGsdData('.planning', 0); // Initial trigger
          return null;
        };

        render(<TestComponent />);

        await new Promise(resolve => setTimeout(resolve, 100));

        const initialParseCount = parseCount;

        // Remount with new trigger (simulating file watcher update)
        const TestComponent2 = () => {
          useGsdData('.planning', 1); // New trigger
          return null;
        };

        render(<TestComponent2 />);

        await new Promise(resolve => setTimeout(resolve, 100));

        // Should have parsed again with new trigger
        expect(parseCount).toBeGreaterThan(initialParseCount);
      });

      test('uses ref pattern to avoid render loop with changedFiles', async () => {
        // This test documents the ref pattern from line 44 of useGsdData.ts
        // Changed files are stored in ref to prevent dependency array issues

        (existsSync as ReturnType<typeof vi.fn>).mockReturnValue(true);
        (readPlanningFile as ReturnType<typeof vi.fn>).mockReturnValue({ content: 'mock' });
        (parseRoadmap as ReturnType<typeof vi.fn>).mockReturnValue([]);
        (parseState as ReturnType<typeof vi.fn>).mockReturnValue({ projectName: 'Test' });
        (parseTodos as ReturnType<typeof vi.fn>).mockReturnValue([]);

        let capturedData: any = null;

        const TestComponent = () => {
          const data = useGsdData('.planning', undefined, ['file1.md']);
          capturedData = data;
          return null;
        };

        render(<TestComponent />);

        await new Promise(resolve => setTimeout(resolve, 100));

        // Should store changed files without causing re-render loop
        expect(capturedData.changedFiles).toEqual(['file1.md']);
        // Hook uses ref pattern to avoid infinite renders
      });
    });
    ```

    Test refresh mechanism and changedFiles handling.
  </action>
  <verify>bun test test/hooks/useGsdData.test.tsx -t "refresh"</verify>
  <done>Refresh trigger and changedFiles handling tested</done>
</task>

<task type="auto">
  <name>Verify useGsdData coverage and run all hook tests</name>
  <files></files>
  <action>
    Run useGsdData tests with coverage:

    ```bash
    bun test test/hooks/useGsdData.test.tsx --coverage
    ```

    Check coverage report for src/hooks/useGsdData.ts:
    1. Verify line coverage >= 75%
    2. All code paths covered: loading, error, success, PROJECT.md parsing
    3. refreshTrigger dependency tested
    4. changedFiles handling tested

    Then run all hook tests:
    ```bash
    bun test test/hooks/
    ```

    Expected outcome:
    - useGsdData tests pass (10-12 tests)
    - All other hook tests still pass
    - Total hook tests: 12 of 13 hooks now tested (up from 11)

    If coverage < 75%:
    1. Identify uncovered lines
    2. Check if they're edge cases or error paths
    3. Add specific test if coverage gap is significant
  </action>
  <verify>bun test test/hooks/useGsdData.test.tsx --coverage 2>&1 | grep -A 5 "useGsdData.ts"</verify>
  <done>useGsdData.ts coverage >= 75%, all hook tests pass</done>
</task>

</tasks>

<verification>
After completion, verify:
1. bun test test/hooks/useGsdData.test.tsx shows all tests passing
2. Coverage report shows useGsdData.ts at 75%+ line coverage
3. All hook tests (12 of 13 hooks) still pass after new tests
4. Loading, error handling, data parsing, refresh behavior all tested
</verification>

<success_criteria>
- useGsdData hook has comprehensive test coverage (75%+ lines)
- Tests cover loading state, error handling, data parsing, refresh triggers
- PROJECT.md name and core value extraction tested
- changedFiles handling and ref pattern verified
- 12 of 13 hooks now have test coverage (up from 11)
</success_criteria>

<output>
After completion, create `.planning/phases/05-test-coverage/05-16-SUMMARY.md`
</output>
