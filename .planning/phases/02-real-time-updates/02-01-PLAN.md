---
phase: 02-real-time-updates
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/hooks/useFileWatcher.ts
  - src/hooks/useChangeHighlight.ts
  - src/hooks/useGsdData.ts
  - src/lib/types.ts
autonomous: true
user_setup: []

must_haves:
  truths:
    - "File watcher detects changes in .planning/ directory"
    - "Rapid file saves are debounced (300ms wait-until-quiet)"
    - "Changed item IDs are tracked with timestamps"
    - "Data reloads when file changes trigger refresh"
  artifacts:
    - path: "src/hooks/useFileWatcher.ts"
      provides: "File watching with debounce"
      exports: ["useFileWatcher"]
    - path: "src/hooks/useChangeHighlight.ts"
      provides: "Changed item tracking with auto-clear"
      exports: ["useChangeHighlight"]
    - path: "src/hooks/useGsdData.ts"
      provides: "Modified to accept refreshTrigger and return changedFiles"
      exports: ["useGsdData"]
  key_links:
    - from: "src/hooks/useFileWatcher.ts"
      to: "node:fs.watch"
      via: "recursive directory watcher"
      pattern: "watch.*recursive.*true"
    - from: "src/hooks/useGsdData.ts"
      to: "refreshTrigger param"
      via: "useEffect dependency"
      pattern: "refreshTrigger"
---

<objective>
Create the file watching and change tracking hooks that enable real-time TUI updates.

Purpose: Establish the reactive infrastructure so the TUI automatically refreshes when planning files change.
Output: Three hooks - useFileWatcher (debounced file watching), useChangeHighlight (temporary highlight tracking), and modified useGsdData (refresh trigger support).
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-real-time-updates/02-CONTEXT.md
@.planning/phases/02-real-time-updates/02-RESEARCH.md
@src/hooks/useGsdData.ts
@src/lib/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useFileWatcher hook with debounce</name>
  <files>src/hooks/useFileWatcher.ts</files>
  <action>
Create a new hook that watches a directory for file changes with debouncing.

Use Bun's native `fs.watch` with `recursive: true` option. Key behaviors:
- Watch the specified path recursively
- Accumulate changed filenames in a Set during rapid saves
- After debounceMs (default 300ms) of quiet, emit the batch of changed files
- Track isRefreshing state (true while accumulating, false after emit)
- Handle watcher errors via onError callback
- Clean up watcher and timers on unmount

Interface:
```typescript
interface UseFileWatcherOptions {
  path: string;
  debounceMs?: number;
  onError?: (error: Error) => void;
}

interface UseFileWatcherResult {
  changedFiles: string[];
  isRefreshing: boolean;
  lastRefresh: number | null;
}
```

Implementation notes:
- Use `watch` from `node:fs` (Bun compatible)
- Store timer ref with `useRef<Timer | null>(null)`
- Store pending files with `useRef<Set<string>>(new Set())`
- Clear timeout before setting new one (wait-until-quiet debounce)
- Add watcher.on('error', ...) handler
- Return cleanup function that closes watcher and clears timer
  </action>
  <verify>
File exists at src/hooks/useFileWatcher.ts
TypeScript compiles: `bun run build` or `bunx tsc --noEmit`
  </verify>
  <done>
Hook exports useFileWatcher function with correct TypeScript types.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create useChangeHighlight hook</name>
  <files>src/hooks/useChangeHighlight.ts</files>
  <action>
Create a hook that tracks which items are currently highlighted (recently changed).

Key behaviors:
- Maintain a Map of itemId -> timestamp when change was detected
- markChanged(itemIds: string[]) adds items with current timestamp
- isHighlighted(itemId: string) returns true if item is in the map
- isFading(itemId: string) returns true if past holdDurationMs (5000ms default)
- Auto-clear items after holdDurationMs + fadeDurationMs (500ms default)
- Store timers in a Map<string, Timer> and clear on unmount

Interface:
```typescript
interface UseChangeHighlightOptions {
  holdDurationMs?: number;  // Default 5000ms - time before fade starts
  fadeDurationMs?: number;  // Default 500ms - fade animation duration
}

interface UseChangeHighlightResult {
  markChanged: (itemIds: string[]) => void;
  isHighlighted: (itemId: string) => boolean;
  isFading: (itemId: string) => boolean;
  changedItems: Map<string, number>;
}
```

Implementation notes:
- Use useState for changedItems Map (triggers re-render)
- Use useRef for timers Map (doesn't trigger re-render)
- markChanged should clear existing timer for item before setting new one
- Timer fires after holdDurationMs + fadeDurationMs, then removes item from Map
- Cleanup effect clears all timers on unmount
- Use useCallback for markChanged, isHighlighted, isFading
  </action>
  <verify>
File exists at src/hooks/useChangeHighlight.ts
TypeScript compiles: `bun run build` or `bunx tsc --noEmit`
  </verify>
  <done>
Hook exports useChangeHighlight function with correct TypeScript types.
  </done>
</task>

<task type="auto">
  <name>Task 3: Modify useGsdData to support refresh triggers</name>
  <files>src/hooks/useGsdData.ts, src/lib/types.ts</files>
  <action>
Modify the existing useGsdData hook to accept a refresh trigger and return changed file info.

Changes to src/lib/types.ts:
- Add to GsdData interface:
```typescript
export interface GsdData {
  // ... existing fields ...
  changedFiles: string[];  // Files that changed in last refresh
}
```

Changes to src/hooks/useGsdData.ts:
- Add second parameter: `refreshTrigger?: number`
- Add `refreshTrigger` to useEffect dependency array
- Add third parameter: `changedFiles: string[] = []`
- Store changedFiles in state and return it
- Update defaultData to include `changedFiles: []`

Function signature becomes:
```typescript
export function useGsdData(
  planningDir = '.planning',
  refreshTrigger?: number,
  changedFiles: string[] = []
): GsdData
```

The refreshTrigger is a timestamp that changes when files change, causing useEffect to re-run.
The changedFiles array is passed in from the file watcher so we can identify what changed.
  </action>
  <verify>
`bun run build` or `bunx tsc --noEmit` passes
useGsdData accepts refreshTrigger and changedFiles parameters
GsdData type includes changedFiles field
  </verify>
  <done>
useGsdData re-fetches data when refreshTrigger changes and includes changedFiles in return value.
  </done>
</task>

</tasks>

<verification>
All three hooks compile and export correctly:
```bash
bunx tsc --noEmit
```

Hook files exist:
- src/hooks/useFileWatcher.ts
- src/hooks/useChangeHighlight.ts
- src/hooks/useGsdData.ts (modified)
</verification>

<success_criteria>
- [ ] useFileWatcher hook created with debounced file watching
- [ ] useChangeHighlight hook created with timed highlight tracking
- [ ] useGsdData modified to accept refresh trigger
- [ ] GsdData type extended with changedFiles
- [ ] All TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-real-time-updates/02-01-SUMMARY.md`
</output>
