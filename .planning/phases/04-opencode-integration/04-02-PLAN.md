---
phase: 04-opencode-integration
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/lib/opencode.ts
  - src/lib/commands.ts
  - src/app.tsx
autonomous: true

must_haves:
  truths:
    - "User can spawn OpenCode session from command palette"
    - "TUI exits to alternate screen, OpenCode runs, TUI resumes"
    - "Toast shows success/failure after spawn attempt"
    - "Spawn works even when no OpenCode server is running"
  artifacts:
    - path: "src/lib/opencode.ts"
      provides: "Terminal handoff function for OpenCode spawn"
      exports: ["spawnOpencodeSession"]
    - path: "src/lib/commands.ts"
      provides: "spawn-opencode command wired to real action"
      contains: "spawn-opencode"
  key_links:
    - from: "src/lib/commands.ts"
      to: "src/lib/opencode.ts"
      via: "import { spawnOpencodeSession }"
      pattern: "spawnOpencodeSession"
    - from: "src/lib/commands.ts"
      to: "showToast callback"
      via: "action parameter"
      pattern: "showToast\\("
---

<objective>
Implement terminal handoff to spawn OpenCode sessions from the TUI.

Purpose: Allow users to start complex workflows in OpenCode directly from the GSD TUI (ACT-04).
Output: Working "spawn-opencode" command that hands off terminal to OpenCode CLI.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-opencode-integration/04-RESEARCH.md

@src/hooks/useExternalEditor.ts
@src/lib/commands.ts
@src/app.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement spawnOpencodeSession function</name>
  <files>src/lib/opencode.ts</files>
  <action>
    Add to `src/lib/opencode.ts` (create if Plan 01 hasn't run yet, or add to existing):

    ```typescript
    import { spawnSync } from 'node:child_process';

    /**
     * Spawn an OpenCode session with terminal handoff.
     * Exits TUI alternate screen, runs OpenCode, then returns.
     *
     * @param initialPrompt - Optional prompt to start the session with
     * @returns true if OpenCode exited successfully (status 0)
     */
    export function spawnOpencodeSession(initialPrompt?: string): boolean {
      // Exit alternate screen (same pattern as useExternalEditor)
      process.stdout.write('\x1b[?1049l');
      process.stdout.write('\x1b[2J\x1b[H');

      try {
        // Build args: opencode OR opencode run "prompt"
        const args = initialPrompt ? ['run', initialPrompt] : [];

        const result = spawnSync('opencode', args, {
          stdio: 'inherit',
          env: process.env,
        });

        // Return to TUI alternate screen
        process.stdout.write('\x1b[?1049h');
        process.stdout.write('\x1b[2J\x1b[H');

        return result.status === 0;
      } catch {
        // Restore screen even on error
        process.stdout.write('\x1b[?1049h');
        process.stdout.write('\x1b[2J\x1b[H');
        return false;
      }
    }
    ```

    This follows the exact pattern from useExternalEditor.ts (openInEditor function).

    Note: If src/lib/opencode.ts already exists from Plan 01, add this function to it.
    If not, create the file with just this function (Plan 01 and 02 are parallel).
  </action>
  <verify>
    1. `bun run typecheck` passes
    2. Function is exported from src/lib/opencode.ts
  </verify>
  <done>spawnOpencodeSession function exists and handles terminal handoff</done>
</task>

<task type="auto">
  <name>Task 2: Add spawn-opencode command</name>
  <files>src/lib/commands.ts</files>
  <action>
    Update `src/lib/commands.ts`:

    1. Add import at top:
    ```typescript
    import { spawnOpencodeSession } from './opencode.ts';
    ```

    2. Add new command to the commands array (after existing commands):
    ```typescript
    {
      name: 'spawn-opencode',
      description: 'Open OpenCode session for complex workflows',
      action: (showToast) => {
        // Note: spawnSync is blocking, so TUI will pause during OpenCode session
        const success = spawnOpencodeSession();
        if (success) {
          showToast('OpenCode session completed', 'success');
        } else {
          showToast('OpenCode session failed or was cancelled', 'warning');
        }
      },
    },
    ```

    Note: Unlike other commands which are stubs, this one has a real implementation.
    The spawnSync call is blocking - the TUI will freeze while OpenCode runs.
    This is intentional (terminal handoff pattern).
  </action>
  <verify>
    1. `bun run typecheck` passes
    2. `bun run lint` passes
    3. `grep "spawn-opencode" src/lib/commands.ts` shows the command
  </verify>
  <done>
    - spawn-opencode command added to commands array
    - Command calls spawnOpencodeSession
    - Shows toast on success/failure
  </done>
</task>

<task type="auto">
  <name>Task 3: Verify integration works end-to-end</name>
  <files>None (verification only)</files>
  <action>
    Manual verification that the integration is wired correctly:

    1. Run `bun run typecheck` - must pass
    2. Run `bun run lint` - must pass (use `bun run lint:fix` if needed)
    3. Run `bun start` in a project with .planning/ directory
    4. Press Ctrl+P to open command palette
    5. Type "spawn" to filter to spawn-opencode command

    At this point, we've verified the command appears in the palette.

    Actually spawning OpenCode requires:
    - OpenCode CLI installed (`which opencode`)
    - If not installed, the spawn will fail gracefully and show warning toast

    The implementation is complete even if OpenCode isn't installed - the graceful
    error handling is part of the design.
  </action>
  <verify>
    1. TUI starts without errors
    2. Command palette shows spawn-opencode
    3. No TypeScript or lint errors
  </verify>
  <done>
    - spawn-opencode appears in command palette
    - All type/lint checks pass
    - ACT-04 requirement addressed
  </done>
</task>

</tasks>

<verification>
```bash
bun run typecheck && bun run lint
```

Optionally, if OpenCode is installed:
```bash
bun start
# Press Ctrl+P, type "spawn", press Enter
# OpenCode should launch
# Press q in OpenCode to exit
# TUI should resume
```
</verification>

<success_criteria>
1. spawnOpencodeSession exported from src/lib/opencode.ts
2. spawn-opencode command in commands array
3. Command executes spawnOpencodeSession and shows toast
4. TypeScript and lint pass
5. Graceful failure when OpenCode CLI not available
</success_criteria>

<output>
After completion, create `.planning/phases/04-opencode-integration/04-02-SUMMARY.md`
</output>
