---
phase: 04-opencode-integration
plan: 05
type: execute
wave: 4
depends_on: ["04-02", "04-03", "04-04"]
files_modified:
  - src/app.tsx
  - src/lib/commands.ts
  - src/components/queue/QueueStatus.tsx
  - src/components/layout/Footer.tsx
autonomous: false

must_haves:
  truths:
    - "User can queue GSD commands from command palette"
    - "Queue status is visible in the TUI"
    - "Commands execute sequentially in OpenCode session"
    - "User can see command completion status"
    - "Footer shows queue-related shortcuts"
  artifacts:
    - path: "src/components/queue/QueueStatus.tsx"
      provides: "Visual queue status display"
      exports: ["QueueStatus"]
    - path: "src/lib/commands.ts"
      provides: "Commands wired to queue"
      contains: "queueInOpencode"
    - path: "src/app.tsx"
      provides: "Queue integration with UI"
      contains: "useCommandQueue"
  key_links:
    - from: "src/app.tsx"
      to: "src/hooks/useCommandQueue.ts"
      via: "hook usage"
      pattern: "useCommandQueue"
    - from: "src/lib/commands.ts"
      to: "queue callback"
      via: "action parameter"
      pattern: "queueCommand"
---

<objective>
Wire queue to command palette and add visual feedback.

Purpose: Complete the integration by connecting queue to UI and providing status visibility (ACT-05).
Output: Fully functional command queueing with visual feedback.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-opencode-integration/04-RESEARCH.md
@.planning/phases/04-opencode-integration/04-02-SUMMARY.md
@.planning/phases/04-opencode-integration/04-03-SUMMARY.md
@.planning/phases/04-opencode-integration/04-04-SUMMARY.md

@src/app.tsx
@src/lib/commands.ts
@src/components/layout/Footer.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create QueueStatus component</name>
  <files>src/components/queue/QueueStatus.tsx</files>
  <action>
    Create `src/components/queue/QueueStatus.tsx`:

    ```typescript
    /**
     * Queue Status Component
     * Displays the current state of the command queue.
     */
    ```

    Props:
    - queue: QueuedCommand[]
    - isProcessing: boolean
    - sessionId?: string

    Display logic:
    1. If queue is empty and not processing: show nothing (return null)
    2. If has items, show compact status bar:
       ```
       Queue: 2 pending | 1 running | 3 complete
       ```
    3. Use colors:
       - pending: yellow
       - running: cyan (with spinner if possible)
       - complete: green
       - failed: red

    Keep it minimal - this will display in the header area or as a toast-like indicator.

    Implementation:
    ```tsx
    export function QueueStatus({ queue, isProcessing }: QueueStatusProps) {
      if (queue.length === 0) return null;

      const counts = {
        pending: queue.filter(c => c.status === 'pending').length,
        running: queue.filter(c => c.status === 'running').length,
        complete: queue.filter(c => c.status === 'complete').length,
        failed: queue.filter(c => c.status === 'failed').length,
      };

      return (
        <Box>
          <Text dimColor>Queue: </Text>
          {counts.pending > 0 && <Text color="yellow">{counts.pending} pending </Text>}
          {counts.running > 0 && <Text color="cyan">{counts.running} running </Text>}
          {counts.complete > 0 && <Text color="green">{counts.complete} done </Text>}
          {counts.failed > 0 && <Text color="red">{counts.failed} failed</Text>}
        </Box>
      );
    }
    ```
  </action>
  <verify>
    1. Component exists at src/components/queue/QueueStatus.tsx
    2. `bun run typecheck` passes
    3. `bun run lint` passes
  </verify>
  <done>
    - QueueStatus displays queue counts by status
    - Returns null when queue is empty
    - Uses appropriate colors for each status
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire queue to commands and app</name>
  <files>src/lib/commands.ts, src/app.tsx</files>
  <action>
    1. Update `src/lib/commands.ts`:
       - Update Command type to include optional queueable flag:
       ```typescript
       export interface Command {
         name: string;
         description: string;
         key?: string;
         action: (showToast: (msg: string, type?: ToastType) => void) => void;
         queueable?: boolean;  // If true, can be queued for OpenCode
       }
       ```

       - Mark GSD commands as queueable:
       ```typescript
       {
         name: 'plan-phase',
         description: 'Create phase plan',
         action: createStubAction('plan-phase'),
         queueable: true,
       },
       ```

       Commands that should be queueable:
       - add-todo, add-phase, insert-phase, progress, verify
       - discuss-phase, plan-phase, execute-phase

       Commands that should NOT be queueable:
       - spawn-opencode (terminal handoff, not queue)
       - connect-session (session management, not queue)

    2. Update `src/app.tsx`:
       - Import useCommandQueue and QueueStatus
       - Add queue state management:
       ```typescript
       const [activeSessionId, setActiveSessionId] = useState<string | undefined>();
       const { queue, add: addToQueue, clear: clearQueue, isProcessing } = useCommandQueue({
         sessionId: activeSessionId,
       });
       ```

       - Pass queue function to command execution context
       - When a queueable command is executed:
         - If no activeSessionId: show toast "No session connected. Use 'c' to connect."
         - If connected: add to queue, show toast "Command queued"

       - Add QueueStatus to header area:
       ```tsx
       <Header ...>
         <QueueStatus queue={queue} isProcessing={isProcessing} sessionId={activeSessionId} />
       </Header>
       ```

       Or render it as a separate row below header.

       - Update session picker onSelect to set activeSessionId
       - When session selected: show toast "Connected to session"

    3. Add keyboard shortcut 'Q' (shift+q) to clear queue:
       ```typescript
       if (input === 'Q') {
         clearQueue();
         showToast('Queue cleared', 'info');
       }
       ```
  </action>
  <verify>
    1. `bun run typecheck` passes
    2. `bun run lint` passes
    3. Commands have queueable flag where appropriate
  </verify>
  <done>
    - Commands marked as queueable
    - Queue integrated into App
    - QueueStatus displays in UI
    - Session connection sets activeSessionId
    - Shift+Q clears queue
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Complete OpenCode integration with session spawning, connection, and command queue</what-built>
  <how-to-verify>
    **Minimum verification (no OpenCode server):**
    1. Run `bun start` in a project with .planning/ directory
    2. Press Ctrl+P to open command palette
    3. Verify "spawn-opencode" command appears
    4. Verify "connect-session" command appears
    5. Press 'c' to try connecting - should show "No OpenCode sessions found"
    6. Press Escape to close any dialogs

    **Full verification (with OpenCode server):**
    1. In another terminal: `opencode serve` (or have OpenCode running)
    2. Run `bun start`
    3. Press 'c' to connect - should show session list
    4. Select a session
    5. Press Ctrl+P, select "plan-phase" (or other queueable command)
    6. Verify command is queued (toast + queue status)
    7. Press Shift+Q to clear queue

    **Verify footer hints:**
    - Check that 'c' (connect) is mentioned if appropriate
    - Check that 'Q' (clear queue) is mentioned if queue is non-empty

    Note: If OpenCode is not installed, spawn-opencode and connect will fail gracefully.
    The implementation is complete regardless of OpenCode availability.
  </how-to-verify>
  <resume-signal>Type "approved" to complete phase, or describe any issues found</resume-signal>
</task>

</tasks>

<verification>
```bash
bun run typecheck && bun run lint && bun test
```

Manual verification as described in checkpoint task.
</verification>

<success_criteria>
1. QueueStatus component displays queue state
2. Commands properly marked as queueable
3. Queue integrates with App state
4. Session connection sets activeSessionId
5. Queueable commands add to queue when connected
6. Clear queue works with Shift+Q
7. All type/lint/test checks pass
8. Human verification approved
</success_criteria>

<output>
After completion, create `.planning/phases/04-opencode-integration/04-05-SUMMARY.md`
</output>
