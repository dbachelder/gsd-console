---
phase: 04-opencode-integration
plan: 05
type: execute
wave: 4
depends_on: ["04-02", "04-03", "04-04"]
files_modified:
  - src/app.tsx
  - src/lib/commands.ts
  - src/components/queue/QueueStatus.tsx
  - src/components/layout/Footer.tsx
autonomous: false

must_haves:
  truths:
    - "User can queue GSD commands from command palette"
    - "Queue status is visible in the TUI"
    - "Commands execute sequentially in OpenCode session"
    - "User can see command completion status"
    - "Footer shows queue-related shortcuts"
  artifacts:
    - path: "src/components/queue/QueueStatus.tsx"
      provides: "Visual queue status display"
      exports: ["QueueStatus"]
    - path: "src/lib/commands.ts"
      provides: "Commands wired to queue"
      contains: "queueable"
    - path: "src/app.tsx"
      provides: "Queue integration with UI"
      contains: "useCommandQueue"
  key_links:
    - from: "src/app.tsx"
      to: "src/hooks/useCommandQueue.ts"
      via: "hook usage"
      pattern: "useCommandQueue"
    - from: "src/lib/commands.ts"
      to: "queue callback"
      via: "action parameter"
      pattern: "queueCommand"
---

<objective>
Wire queue to command palette and add visual feedback.

Purpose: Complete the integration by connecting queue to UI and providing status visibility (ACT-05).
Output: Fully functional command queueing with visual feedback.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-opencode-integration/04-RESEARCH.md
@.planning/phases/04-opencode-integration/04-02-SUMMARY.md
@.planning/phases/04-opencode-integration/04-03-SUMMARY.md
@.planning/phases/04-opencode-integration/04-04-SUMMARY.md

@src/app.tsx
@src/lib/commands.ts
@src/components/layout/Footer.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create QueueStatus component</name>
  <files>src/components/queue/QueueStatus.tsx</files>
  <action>
    Create `src/components/queue/QueueStatus.tsx`:

    ```typescript
    /**
     * Queue Status Component
     * Displays the current state of the command queue.
     */
    ```

    Props:
    - queue: QueuedCommand[]
    - isProcessing: boolean
    - sessionId?: string

    Display logic:
    1. If queue is empty and not processing: show nothing (return null)
    2. If has items, show compact status bar:
       ```
       Queue: 2 pending | 1 running | 3 complete
       ```
    3. Use colors:
       - pending: yellow
       - running: cyan (with spinner if possible)
       - complete: green
       - failed: red

    Keep it minimal - this will display in the header area or as a toast-like indicator.

    Implementation:
    ```tsx
    export function QueueStatus({ queue, isProcessing }: QueueStatusProps) {
      if (queue.length === 0) return null;

      const counts = {
        pending: queue.filter(c => c.status === 'pending').length,
        running: queue.filter(c => c.status === 'running').length,
        complete: queue.filter(c => c.status === 'complete').length,
        failed: queue.filter(c => c.status === 'failed').length,
      };

      return (
        <Box>
          <Text dimColor>Queue: </Text>
          {counts.pending > 0 && <Text color="yellow">{counts.pending} pending </Text>}
          {counts.running > 0 && <Text color="cyan">{counts.running} running </Text>}
          {counts.complete > 0 && <Text color="green">{counts.complete} done </Text>}
          {counts.failed > 0 && <Text color="red">{counts.failed} failed</Text>}
        </Box>
      );
    }
    ```
  </action>
  <verify>
    1. Component exists at src/components/queue/QueueStatus.tsx
    2. `bun run typecheck` passes
    3. `bun run lint` passes
  </verify>
  <done>
    - QueueStatus displays queue counts by status
    - Returns null when queue is empty
    - Uses appropriate colors for each status
  </done>
</task>

<task type="auto">
  <name>Task 2: Update Command type and mark queueable commands</name>
  <files>src/lib/commands.ts</files>
  <action>
    Update `src/lib/commands.ts`:

    1. Update Command type to include optional queueable flag:
    ```typescript
    export interface Command {
      name: string;
      description: string;
      key?: string;
      action: (showToast: (msg: string, type?: ToastType) => void) => void;
      queueable?: boolean;  // If true, can be queued for OpenCode
    }
    ```

    2. Mark GSD commands as queueable by adding `queueable: true`:

    Commands that SHOULD be queueable:
    - add-todo
    - add-phase
    - insert-phase
    - progress
    - verify
    - discuss-phase
    - plan-phase
    - execute-phase

    Commands that should NOT be queueable (leave queueable undefined/false):
    - spawn-opencode (terminal handoff, not queue)
    - connect-session (session management, not queue)
    - Any UI-only commands

    Example:
    ```typescript
    {
      name: 'plan-phase',
      description: 'Create phase plan',
      action: createStubAction('plan-phase'),
      queueable: true,
    },
    ```
  </action>
  <verify>
    1. `bun run typecheck` passes
    2. `bun run lint` passes
    3. Verify commands have queueable flag set appropriately
  </verify>
  <done>
    - Command type has queueable field
    - GSD commands marked queueable: true
    - Session/spawn commands NOT marked queueable
  </done>
</task>

<task type="auto">
  <name>Task 3: Integrate useCommandQueue into App</name>
  <files>src/app.tsx</files>
  <action>
    Update `src/app.tsx` to integrate the command queue:

    1. Import useCommandQueue and QueueStatus:
    ```typescript
    import { useCommandQueue } from './hooks/useCommandQueue';
    import { QueueStatus } from './components/queue/QueueStatus';
    ```

    2. Initialize queue hook with activeSessionId (from Plan 03):
    ```typescript
    const { queue, add: addToQueue, clear: clearQueue, isProcessing } = useCommandQueue({
      sessionId: activeSessionId,
    });
    ```

    3. Add QueueStatus to UI (below header or in header area):
    ```tsx
    <QueueStatus queue={queue} isProcessing={isProcessing} sessionId={activeSessionId} />
    ```

    4. Add keyboard shortcut 'Q' (shift+q) to clear queue:
    ```typescript
    if (input === 'Q') {
      clearQueue();
      showToast('Queue cleared', 'info');
    }
    ```

    Note: The queue's add function will be used in Task 4.
    The activeSessionId state should already exist from Plan 03.
  </action>
  <verify>
    1. `bun run typecheck` passes
    2. `bun run lint` passes
    3. QueueStatus renders in UI
    4. Shift+Q clears queue
  </verify>
  <done>
    - useCommandQueue integrated into App
    - QueueStatus displays in UI
    - Shift+Q clears queue
    - Queue uses activeSessionId from session picker
  </done>
</task>

<task type="auto">
  <name>Task 4: Wire command palette to queue</name>
  <files>src/app.tsx</files>
  <action>
    Update command execution flow in `src/app.tsx`:

    When a command is executed from command palette:

    1. Check if command.queueable is true
    2. If queueable AND activeSessionId is set:
       - Call addToQueue(command.name)
       - Show toast "Queued: {command.name}"
    3. If queueable BUT no activeSessionId:
       - Show toast "No session connected. Press 'c' to connect." (warning)
    4. If NOT queueable:
       - Execute command.action() as before (existing behavior)

    Implementation in command palette onExecute callback:
    ```typescript
    const handleCommandExecute = (command: Command) => {
      setShowCommandPalette(false);

      if (command.queueable) {
        if (!activeSessionId) {
          showToast("No session connected. Press 'c' to connect.", 'warning');
          return;
        }
        addToQueue(command.name);
        showToast(`Queued: ${command.name}`, 'info');
      } else {
        command.action(showToast);
      }
    };
    ```

    This creates the key flow:
    Command Palette -> queueable check -> addToQueue -> useCommandQueue -> sendPrompt
  </action>
  <verify>
    1. `bun run typecheck` passes
    2. `bun run lint` passes
    3. Queueable commands get queued when session connected
    4. Warning shown when no session connected
    5. Non-queueable commands execute normally
  </verify>
  <done>
    - Command palette checks queueable flag
    - Queueable commands added to queue when connected
    - Warning toast when no session connected
    - Non-queueable commands execute immediately
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Complete OpenCode integration with session spawning, connection, and command queue</what-built>
  <how-to-verify>
    **Minimum verification (no OpenCode server):**
    1. Run `bun start` in a project with .planning/ directory
    2. Press Ctrl+P to open command palette
    3. Verify "spawn-opencode" command appears
    4. Verify "connect-session" command appears
    5. Press 'c' to try connecting - should show "No OpenCode sessions found"
    6. Try executing a queueable command (e.g., plan-phase) - should show "No session connected"
    7. Press Escape to close any dialogs

    **Full verification (with OpenCode server):**
    1. In another terminal: `opencode serve` (or have OpenCode running)
    2. Run `bun start`
    3. Press 'c' to connect - should show session list
    4. Select a session - should show "Connected to session: xxx..."
    5. Press Ctrl+P, select "plan-phase" (or other queueable command)
    6. Verify command is queued (toast "Queued: plan-phase" + queue status appears)
    7. Press Shift+Q to clear queue - should show "Queue cleared"

    **Verify footer hints:**
    - Check that 'c' (connect) is mentioned if appropriate
    - Check that 'Q' (clear queue) is mentioned if queue is non-empty

    Note: If OpenCode is not installed, spawn-opencode and connect will fail gracefully.
    The implementation is complete regardless of OpenCode availability.
  </how-to-verify>
  <resume-signal>Type "approved" to complete phase, or describe any issues found</resume-signal>
</task>

</tasks>

<verification>
```bash
bun run typecheck && bun run lint && bun test
```

Manual verification as described in checkpoint task.
</verification>

<success_criteria>
1. QueueStatus component displays queue state
2. Commands properly marked as queueable
3. useCommandQueue integrated into App
4. Command palette routes queueable commands to queue
5. Session connection required for queueing (warning if not connected)
6. Clear queue works with Shift+Q
7. All type/lint/test checks pass
8. Human verification approved
</success_criteria>

<output>
After completion, create `.planning/phases/04-opencode-integration/04-05-SUMMARY.md`
</output>
