---
phase: 04-opencode-integration
plan: 04
type: execute
wave: 3
depends_on: ["04-01", "04-03"]
files_modified:
  - src/hooks/useCommandQueue.ts
  - src/hooks/useSessionEvents.ts
  - src/lib/opencode.ts
  - src/lib/types.ts
autonomous: true

must_haves:
  truths:
    - "Commands can be queued for sequential execution"
    - "Queue processes commands one at a time"
    - "Queue monitors session idle events via SSE"
    - "Queue handles errors gracefully without crashing"
  artifacts:
    - path: "src/hooks/useCommandQueue.ts"
      provides: "Command queue state management"
      exports: ["useCommandQueue"]
    - path: "src/hooks/useSessionEvents.ts"
      provides: "SSE event subscription hook"
      exports: ["useSessionEvents"]
    - path: "src/lib/types.ts"
      provides: "Queue-related type definitions"
      contains: "QueuedCommand"
  key_links:
    - from: "src/hooks/useCommandQueue.ts"
      to: "src/hooks/useSessionEvents.ts"
      via: "subscribes to session events"
      pattern: "useSessionEvents"
    - from: "src/hooks/useCommandQueue.ts"
      to: "src/lib/opencode.ts"
      via: "sends prompts to session"
      pattern: "sendPrompt"
---

<objective>
Implement command queue with SSE-based session monitoring.

Purpose: Allow queuing multiple GSD commands for sequential execution in OpenCode (ACT-05).
Output: Queue management hook that processes commands one at a time.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-opencode-integration/04-RESEARCH.md
@.planning/phases/04-opencode-integration/04-01-SUMMARY.md
@.planning/phases/04-opencode-integration/04-03-SUMMARY.md

@src/lib/opencode.ts
@src/lib/types.ts
@src/hooks/useOpencodeConnection.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add queue types and prompt function</name>
  <files>src/lib/types.ts, src/lib/opencode.ts</files>
  <action>
    1. Add to `src/lib/types.ts`:
    ```typescript
    /** Queued command status */
    export type QueuedCommandStatus = 'pending' | 'running' | 'complete' | 'failed';

    /** A command in the execution queue */
    export interface QueuedCommand {
      id: string;
      command: string;
      status: QueuedCommandStatus;
      error?: string;
      queuedAt: number;
      startedAt?: number;
      completedAt?: number;
    }

    /** Queue state */
    export interface CommandQueueState {
      commands: QueuedCommand[];
      isProcessing: boolean;
      sessionId?: string;
      error?: Error;
    }
    ```

    2. Add to `src/lib/opencode.ts`:
    ```typescript
    /**
     * Send a prompt to an OpenCode session.
     * Returns true if prompt was sent successfully.
     */
    export async function sendPrompt(sessionId: string, text: string): Promise<boolean> {
      try {
        const client = createClient();
        await client.session.prompt({
          path: { id: sessionId },
          body: {
            parts: [{ type: 'text', text }],
          },
        });
        return true;
      } catch {
        return false;
      }
    }

    /**
     * Create a new OpenCode session.
     * Returns session ID or null on failure.
     */
    export async function createSession(title?: string): Promise<string | null> {
      try {
        const client = createClient();
        const response = await client.session.create({
          body: { title: title ?? 'GSD Queue' },
        });
        return response.data?.id ?? null;
      } catch {
        return null;
      }
    }
    ```

    All functions handle errors gracefully and return failure values.
  </action>
  <verify>
    1. `bun run typecheck` passes
    2. Types exported from types.ts
    3. Functions exported from opencode.ts
  </verify>
  <done>
    - QueuedCommand and CommandQueueState types defined
    - sendPrompt sends text to session
    - createSession creates new session
  </done>
</task>

<task type="auto">
  <name>Task 2: Create session events hook</name>
  <files>src/hooks/useSessionEvents.ts</files>
  <action>
    Create `src/hooks/useSessionEvents.ts`:

    ```typescript
    /**
     * Session Events Hook
     * Subscribes to OpenCode SSE events for a specific session.
     */
    ```

    Hook interface:
    ```typescript
    interface UseSessionEventsProps {
      sessionId?: string;
      onIdle?: () => void;
      onError?: (error: string) => void;
      enabled?: boolean;
    }

    export function useSessionEvents(props: UseSessionEventsProps): void
    ```

    Implementation:
    1. useEffect that subscribes when sessionId and enabled are truthy
    2. Use SDK's event.subscribe() method
    3. Filter events by sessionId (ignore events for other sessions)
    4. Call onIdle when session.idle event received
    5. Call onError when session.error event received
    6. Store AbortController in ref for cleanup
    7. Abort subscription on unmount or when sessionId changes

    Pattern from RESEARCH.md:
    ```typescript
    const eventStream = await client.event.subscribe();
    for await (const event of eventStream) {
      if (event.type === 'session.idle' && event.sessionID === sessionId) {
        onIdle?.();
      }
    }
    ```

    **IMPORTANT:** The for-await loop runs indefinitely. Need to:
    - Track mounted state
    - Break loop on unmount
    - Handle stream abort gracefully (catch AbortError)

    Consider using a simpler polling approach if SSE proves complex:
    ```typescript
    // Fallback: poll session status every 2 seconds
    const interval = setInterval(async () => {
      const status = await getSessionStatus(sessionId);
      if (status === 'idle') onIdle?.();
    }, 2000);
    ```

    Start with SSE, fall back to polling if issues arise.
  </action>
  <verify>
    1. `bun run typecheck` passes
    2. Hook exported from useSessionEvents.ts
    3. `bun run lint` passes
  </verify>
  <done>
    - useSessionEvents hook subscribes to session events
    - Calls onIdle when session becomes idle
    - Properly cleans up subscription on unmount
  </done>
</task>

<task type="auto">
  <name>Task 3: Create command queue hook</name>
  <files>src/hooks/useCommandQueue.ts</files>
  <action>
    Create `src/hooks/useCommandQueue.ts`:

    ```typescript
    /**
     * Command Queue Hook
     * Manages a queue of commands for sequential execution in OpenCode.
     */
    ```

    Hook interface:
    ```typescript
    interface UseCommandQueueProps {
      sessionId?: string;
    }

    interface UseCommandQueueReturn {
      queue: QueuedCommand[];
      isProcessing: boolean;
      add: (command: string) => void;
      clear: () => void;
      error?: Error;
    }

    export function useCommandQueue(props: UseCommandQueueProps): UseCommandQueueReturn
    ```

    Implementation:
    1. State: queue (QueuedCommand[]), isProcessing (boolean)
    2. `add(command)`: Add command to queue with unique ID, status 'pending'
    3. useSessionEvents to listen for session.idle
    4. When idle and queue has pending commands:
       - Find first pending command
       - Set status to 'running'
       - Call sendPrompt
       - If sendPrompt fails, set status to 'failed' with error
       - On success, wait for next idle event (status becomes 'complete')
    5. `clear()`: Clear all commands from queue

    Generate unique IDs with:
    ```typescript
    const id = `cmd-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;
    ```

    State updates should be done with functional updates to avoid stale closures:
    ```typescript
    setQueue(prev => prev.map(c => c.id === id ? { ...c, status: 'running' } : c));
    ```

    Edge cases:
    - No sessionId: queue commands but don't process
    - Session disconnects: mark running command as failed
    - Rapid adds: all go to pending, processed in order
  </action>
  <verify>
    1. `bun run typecheck` passes
    2. `bun run lint` passes
    3. Hook exports add, clear, queue, isProcessing
  </verify>
  <done>
    - useCommandQueue manages command queue state
    - add() queues commands
    - Queue processes commands sequentially on session.idle
    - Error handling for failed commands
  </done>
</task>

</tasks>

<verification>
```bash
bun run typecheck && bun run lint
```

Queue functionality is internal - full verification will be in Plan 05 when wired to UI.
</verification>

<success_criteria>
1. QueuedCommand and CommandQueueState types defined
2. sendPrompt and createSession functions work
3. useSessionEvents subscribes to SSE events
4. useCommandQueue manages queue state
5. All type/lint checks pass
</success_criteria>

<output>
After completion, create `.planning/phases/04-opencode-integration/04-04-SUMMARY.md`
</output>
