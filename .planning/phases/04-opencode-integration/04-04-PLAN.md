---
phase: 04-opencode-integration
plan: 04
type: execute
wave: 3
depends_on: ["04-01", "04-03"]
files_modified:
  - src/hooks/useBackgroundJobs.ts
  - src/hooks/useSessionEvents.ts
  - src/lib/opencode.ts
  - src/lib/types.ts
autonomous: true

must_haves:
  truths:
    - "Background jobs can be created for headless execution"
    - "Jobs are processed one at a time via SSE monitoring"
    - "Job retention: keep last 5 successful + 5 failed (auto-prune)"
    - "Jobs can be cancelled with confirmation"
    - "Toast shown on job start and completion"
  artifacts:
    - path: "src/hooks/useBackgroundJobs.ts"
      provides: "Background job state management"
      exports: ["useBackgroundJobs"]
    - path: "src/hooks/useSessionEvents.ts"
      provides: "SSE event subscription hook"
      exports: ["useSessionEvents"]
    - path: "src/lib/types.ts"
      provides: "Background job type definitions"
      contains: "BackgroundJob"
  key_links:
    - from: "src/hooks/useBackgroundJobs.ts"
      to: "src/hooks/useSessionEvents.ts"
      via: "subscribes to session events"
      pattern: "useSessionEvents"
    - from: "src/hooks/useBackgroundJobs.ts"
      to: "src/lib/opencode.ts"
      via: "sends prompts to session"
      pattern: "sendPrompt"
---

<objective>
Implement background job management with SSE-based session monitoring.

Purpose: Allow running GSD commands in headless mode with status tracking (per CONTEXT.md "Background Panel" requirements).
Output: Background job hook that processes jobs sequentially with retention and cancellation.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/04-opencode-integration/04-RESEARCH.md
@.planning/phases/04-opencode-integration/04-CONTEXT.md
@.planning/phases/04-opencode-integration/04-01-SUMMARY.md
@.planning/phases/04-opencode-integration/04-03-SUMMARY.md

@src/lib/opencode.ts
@src/lib/types.ts
@src/hooks/useOpencodeConnection.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add background job types and prompt function</name>
  <files>src/lib/types.ts, src/lib/opencode.ts</files>
  <action>
    1. Add to `src/lib/types.ts` (rename from "Queue" to "Background" per CONTEXT.md):
    ```typescript
    /** Background job status */
    export type BackgroundJobStatus = 'pending' | 'running' | 'complete' | 'failed' | 'cancelled';

    /** A background job for headless execution */
    export interface BackgroundJob {
      id: string;
      command: string;
      status: BackgroundJobStatus;
      output?: string;           // Captured output for expandable display
      error?: string;
      queuedAt: number;
      startedAt?: number;
      completedAt?: number;
    }

    /** Background jobs state */
    export interface BackgroundJobsState {
      jobs: BackgroundJob[];
      isProcessing: boolean;
      sessionId?: string;
      error?: Error;
    }
    ```

    2. Add to `src/lib/opencode.ts`:
    ```typescript
    /**
     * Send a prompt to an OpenCode session.
     * Returns true if prompt was sent successfully.
     */
    export async function sendPrompt(sessionId: string, text: string): Promise<boolean> {
      try {
        const client = createClient();
        await client.session.prompt({
          path: { id: sessionId },
          body: {
            parts: [{ type: 'text', text }],
          },
        });
        return true;
      } catch {
        return false;
      }
    }

    /**
     * Create a new OpenCode session for background jobs.
     * Returns session ID or null on failure.
     */
    export async function createSession(title?: string): Promise<string | null> {
      try {
        const client = createClient();
        const response = await client.session.create({
          body: { title: title ?? 'GSD Background' },
        });
        return response.data?.id ?? null;
      } catch {
        return null;
      }
    }
    ```

    All functions handle errors gracefully and return failure values.
  </action>
  <verify>
    1. `bun run typecheck` passes
    2. Types exported from types.ts
    3. Functions exported from opencode.ts
  </verify>
  <done>
    - BackgroundJob and BackgroundJobsState types defined
    - sendPrompt sends text to session
    - createSession creates new session for background work
  </done>
</task>

<task type="auto">
  <name>Task 2: Create session events hook</name>
  <files>src/hooks/useSessionEvents.ts</files>
  <action>
    Create `src/hooks/useSessionEvents.ts`:

    ```typescript
    /**
     * Session Events Hook
     * Subscribes to OpenCode SSE events for a specific session.
     */
    ```

    Hook interface:
    ```typescript
    interface UseSessionEventsProps {
      sessionId?: string;
      onIdle?: () => void;
      onOutput?: (text: string) => void;  // Capture output for expandable display
      onError?: (error: string) => void;
      enabled?: boolean;
    }

    export function useSessionEvents(props: UseSessionEventsProps): void
    ```

    Implementation:
    1. useEffect that subscribes when sessionId and enabled are truthy
    2. Use SDK's event.subscribe() method
    3. Filter events by sessionId (ignore events for other sessions)
    4. Call onIdle when session.idle event received
    5. Call onOutput when text output events received
    6. Call onError when session.error event received
    7. Store AbortController in ref for cleanup
    8. Abort subscription on unmount or when sessionId changes

    Pattern from RESEARCH.md:
    ```typescript
    const eventStream = await client.event.subscribe();
    for await (const event of eventStream) {
      if (event.type === 'session.idle' && event.sessionID === sessionId) {
        onIdle?.();
      }
    }
    ```

    **IMPORTANT:** The for-await loop runs indefinitely. Need to:
    - Track mounted state
    - Break loop on unmount
    - Handle stream abort gracefully (catch AbortError)

    Consider using a simpler polling approach if SSE proves complex:
    ```typescript
    // Fallback: poll session status every 2 seconds
    const interval = setInterval(async () => {
      const status = await getSessionStatus(sessionId);
      if (status === 'idle') onIdle?.();
    }, 2000);
    ```

    Start with SSE, fall back to polling if issues arise.
  </action>
  <verify>
    1. `bun run typecheck` passes
    2. Hook exported from useSessionEvents.ts
    3. `bun run lint` passes
  </verify>
  <done>
    - useSessionEvents hook subscribes to session events
    - Calls onIdle when session becomes idle
    - Calls onOutput to capture text for display
    - Properly cleans up subscription on unmount
  </done>
</task>

<task type="auto">
  <name>Task 3: Create background jobs hook with retention</name>
  <files>src/hooks/useBackgroundJobs.ts</files>
  <action>
    Create `src/hooks/useBackgroundJobs.ts`:

    ```typescript
    /**
     * Background Jobs Hook
     * Manages background jobs for headless execution in OpenCode.
     * Per CONTEXT.md: Keep last 5 success + 5 errors, auto-prune older.
     */
    ```

    Hook interface:
    ```typescript
    interface UseBackgroundJobsProps {
      sessionId?: string;
      showToast?: (msg: string, type?: ToastType) => void;  // Toast on start/complete
    }

    interface UseBackgroundJobsReturn {
      jobs: BackgroundJob[];
      isProcessing: boolean;
      add: (command: string) => void;
      cancel: (jobId: string) => void;  // Per CONTEXT.md: jobs cancelable
      clear: () => void;
      error?: Error;
    }

    export function useBackgroundJobs(props: UseBackgroundJobsProps): UseBackgroundJobsReturn
    ```

    Implementation:
    1. State: jobs (BackgroundJob[]), isProcessing (boolean)

    2. `add(command)`:
       - Add job with unique ID, status 'pending'
       - Show toast: "Background: {command} queued"

    3. **Retention logic (per CONTEXT.md: keep 5 success + 5 errors):**
       ```typescript
       function pruneJobs(jobs: BackgroundJob[]): BackgroundJob[] {
         const active = jobs.filter(j =>
           j.status === 'pending' || j.status === 'running'
         );
         const success = jobs
           .filter(j => j.status === 'complete')
           .slice(-5);  // Keep last 5
         const failed = jobs
           .filter(j => j.status === 'failed' || j.status === 'cancelled')
           .slice(-5);  // Keep last 5
         return [...active, ...success, ...failed];
       }
       ```
       Call pruneJobs after each status change.

    4. `cancel(jobId)`:
       - If job is 'pending': set status to 'cancelled'
       - If job is 'running': attempt to abort (may need session abort API)
       - Show toast: "Background: {command} cancelled"

    5. useSessionEvents to listen for session.idle:
       - When idle and has pending jobs:
         - Find first pending job
         - Set status to 'running', startedAt = Date.now()
         - Show toast: "Background: {command} started"
         - Call sendPrompt
         - If sendPrompt fails, set status to 'failed' with error
       - When job completes (next idle after running):
         - Set status to 'complete', completedAt = Date.now()
         - Show toast: "Background: {command} complete"

    6. `clear()`: Remove all jobs (confirmation handled by UI in Plan 05)

    Generate unique IDs with:
    ```typescript
    const id = `job-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;
    ```

    State updates should use functional updates to avoid stale closures.

    Edge cases:
    - No sessionId: jobs stay pending (don't process)
    - Session disconnects: mark running job as failed
    - Rapid adds: all go to pending, processed in order
  </action>
  <verify>
    1. `bun run typecheck` passes
    2. `bun run lint` passes
    3. Hook exports add, cancel, clear, jobs, isProcessing
  </verify>
  <done>
    - useBackgroundJobs manages job state
    - add() creates pending jobs with toast
    - cancel() cancels jobs with toast
    - Retention: keeps last 5 success + 5 failed
    - Toasts on job start and completion
    - Jobs process sequentially on session.idle
  </done>
</task>

</tasks>

<verification>
```bash
bun run typecheck && bun run lint
```

Background job functionality is internal - full verification will be in Plan 05 when wired to BackgroundView.
</verification>

<success_criteria>
1. BackgroundJob and BackgroundJobsState types defined (not Queue)
2. sendPrompt and createSession functions work
3. useSessionEvents subscribes to SSE events with output capture
4. useBackgroundJobs manages job state with retention
5. Toasts fire on job start and completion
6. Cancel sets job status to cancelled
7. All type/lint checks pass
</success_criteria>

<output>
After completion, create `.planning/phases/04-opencode-integration/04-04-SUMMARY.md`
</output>
