---
phase: 04-opencode-integration
plan: 09
type: execute
wave: 1
depends_on: []
files_modified: [src/app.tsx, src/hooks/useBackgroundJobs.ts]
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "Headless mode creates a new background OpenCode session"
    - "Headless commands are sent to the background session, not primary"
    - "Primary mode sends commands to the connected activeSessionId"
  artifacts:
    - path: "src/app.tsx"
      provides: "handleModeSelect with headless session creation"
      contains: "createSession"
    - path: "src/hooks/useBackgroundJobs.ts"
      provides: "Job queue management with explicit sessionId per job"
      exports: ["add"]
  key_links:
    - from: "src/app.tsx (handleModeSelect, headless case)"
      to: "src/lib/opencode.ts (createSession)"
      via: "createSession() API call to create new background session"
      pattern: "createSession"
    - from: "src/app.tsx (handleModeSelect, headless case)"
      to: "src/hooks/useBackgroundJobs.ts (add)"
      via: "add(jobCommand, newSessionId) with new session ID"
      pattern: "addBackgroundJob.*sessionId"
---

<objective>
Fix headless execution mode to create dedicated background sessions instead of sending commands to the primary session

Purpose: Currently both headless and primary modes call addBackgroundJob(fullCommand) which sends commands to the same activeSessionId. Headless should create a new background session for isolated execution.
Output: Headless commands execute in dedicated background sessions, primary commands execute in connected session
</object>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/04-opencode-integration/04-UAT.md
@.planning/phases/04-opencode-integration/04-04-SUMMARY.md
@src/app.tsx
@src/hooks/useBackgroundJobs.ts
@src/lib/opencode.ts
</context>

<tasks>

<task type="auto">
  <name>Modify useBackgroundJobs to accept explicit sessionId per job</name>
  <files>src/hooks/useBackgroundJobs.ts</files>
  <action>
Change useBackgroundJobs to support per-job sessionId instead of global sessionId:

1. Update add() function signature to accept optional sessionId parameter:
   `add: (command: string, sessionId?: string) => void;`

2. Update add() implementation to use provided sessionId or default to hook's sessionId:
   - In add() callback, add `explicitSessionId?: string` parameter
   - Store sessionId in job object: `sessionId: explicitSessionId ?? sessionId`
   - Pass job's sessionId to sendPrompt() call instead of hook's sessionId

3. Update handleIdle() to use job's sessionId:
   - Change sendPrompt() call to use `job.sessionId` instead of `sessionId` prop
   - This ensures each job uses its designated session

Reference existing code: Line 48 (interface), Line 101 (sessionId usage), Line 208-228 (add function).
</action>
  <verify>TypeScript compiles: `bun run typecheck`</verify>
  <done>useBackgroundJobs add() accepts explicit sessionId per job, jobs execute in their designated sessions</done>
</task>

<task type="auto">
  <name>Create background session for headless mode in handleModeSelect</name>
  <files>src/app.tsx</files>
  <action>
Update handleModeSelect() in app.tsx to create dedicated background sessions for headless mode:

1. Import createSession from lib/opencode.ts (already imported on line 27)

2. In headless case (lines 198-202):
   - Call `createSession()` to create new background session
   - If session creation succeeds, call `addBackgroundJob(fullCommand, newSessionId)` with new session ID
   - If session creation fails, show warning toast: "Failed to create background session"
   - Keep the async pattern for session creation (like interactive mode)

3. Primary mode (lines 218-228) remains unchanged - uses activeSessionId

4. Interactive mode (lines 204-216) remains unchanged - uses terminal handoff

Reference existing code: Line 27 (createSession import), Line 198-202 (headless case), Line 227 (primary mode).
</action>
  <verify>TypeScript compiles: `bun run typecheck`</verify>
  <done>Headless mode creates new background session, adds job to that session; primary mode uses activeSessionId</done>
</task>

</tasks>

<verification>
1. Verify TypeScript compiles: `bun run typecheck`
2. Verify linter passes: `bun run lint`
3. Manual test: Run TUI, execute headless command, verify new session is created (check OpenCode session list)
4. Manual test: Run TUI, connect to session, execute primary command, verify it goes to connected session
</verification>

<success_criteria>
- Headless mode creates a new OpenCode session for each command (via createSession)
- Headless commands are sent to the background session, not the primary activeSessionId
- Primary mode continues to send commands to the connected session (activeSessionId)
- Both modes now functionally distinct
</success_criteria>

<output>
After completion, create `.planning/phases/04-opencode-integration/04-09-SUMMARY.md`
</output>
