---
phase: 04-opencode-integration
plan: 07
type: execute
wave: 1
depends_on: []
files_modified:
  - src/components/palette/CommandPalette.tsx
  - src/hooks/useCommandPalette.ts
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "User can Tab-complete a command name from partial input"
    - "After Tab completion, cursor is positioned after command name with space"
    - "User can type arguments after the completed command name"
  artifacts:
    - path: "src/components/palette/CommandPalette.tsx"
      provides: "Tab key handling for completion"
      min_lines: 100
    - path: "src/hooks/useCommandPalette.ts"
      provides: "State management for completion"
  key_links:
    - from: "CommandPalette Tab handler"
      to: "query state"
      via: "setQuery with completed command name"
    - from: "completed query"
      to: "fuzzy filter"
      via: "filter updates to show matching commands"
---

<objective>
Add Tab completion to command palette that autocompletes the command name and allows typing arguments.

Purpose: Close UAT gap - users should be able to type partial command, press Tab to complete, then add arguments (e.g., "plan" + Tab -> "plan-phase " then type "4").

Output: Tab key completes command name, leaves cursor ready for argument input.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/STATE.md

@src/components/palette/CommandPalette.tsx
@src/hooks/useCommandPalette.ts
@src/app.tsx (lines 343-364 for palette integration)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Tab handling to CommandPalette</name>
  <files>src/components/palette/CommandPalette.tsx</files>
  <action>
The challenge is that `TextInput` from @inkjs/ui doesn't expose a way to intercept Tab key - it only provides `onChange` and `onSubmit`. We need to add a `useInput` handler that runs alongside TextInput.

However, there's a conflict: when multiple useInput hooks are active, Ink dispatches to all of them. TextInput has its own internal input handler. We need to intercept Tab before TextInput sees it.

**Solution approach:**
1. Add `useInput` hook in CommandPalette that handles Tab key
2. When Tab is pressed and there's a filtered command:
   - Get the top match (index 0 or selected index)
   - Set query to `{commandName} ` (command name plus space)
   - This triggers the fuzzy filter to update
3. The TextInput continues to work normally for other keys

```typescript
import { useInput } from 'ink';

// Inside CommandPalette component, add this hook:
useInput((input, key) => {
  // Tab: autocomplete to selected command
  if (key.tab && filteredCommands.length > 0) {
    const selectedCommand = filteredCommands[selectedIndex];
    if (selectedCommand) {
      // Set query to command name + space (ready for args)
      onQueryChange(selectedCommand.name + ' ');
    }
  }
});
```

**Note:** TextInput from @inkjs/ui is uncontrolled - it doesn't accept a `value` prop. The `onChange` callback receives the current input but we can't set it programmatically.

**Alternative approach if uncontrolled TextInput blocks us:**
Create a controlled text input using raw `useInput` that:
- Tracks input string in local state
- Handles character input, backspace, and Tab
- Renders the input text manually

If needed, replace TextInput entirely:
```typescript
const [inputValue, setInputValue] = useState('');

useInput((input, key) => {
  if (key.tab && filteredCommands.length > 0) {
    const cmd = filteredCommands[selectedIndex];
    if (cmd) {
      const completed = cmd.name + ' ';
      setInputValue(completed);
      onQueryChange(completed);
    }
    return;
  }

  if (key.return) {
    handleSubmit();
    return;
  }

  if (key.backspace || key.delete) {
    setInputValue(prev => prev.slice(0, -1));
    onQueryChange(inputValue.slice(0, -1));
    return;
  }

  // Regular character input
  if (input && !key.ctrl && !key.meta) {
    const newValue = inputValue + input;
    setInputValue(newValue);
    onQueryChange(newValue);
  }
});

// Render:
<Text color="blue" bold>:</Text>
<Text>{inputValue || 'type command...'}</Text>
<Text>_</Text>  {/* cursor */}
```

Choose the approach that works. Test by:
1. Open palette with ':'
2. Type "plan"
3. Press Tab - should complete to "plan-phase "
4. Type "4"
5. Press Enter - should execute with "plan-phase 4" context
  </action>
  <verify>
1. `bun run typecheck` passes
2. Open TUI, press ':' to open palette
3. Type "dis" (partial for discuss-phase)
4. Press Tab - query should become "discuss-phase "
5. Verify cursor is after the space, ready for input
  </verify>
  <done>Tab completes partial command to full command name with trailing space.</done>
</task>

<task type="auto">
  <name>Task 2: Handle command execution with arguments</name>
  <files>src/components/palette/CommandPalette.tsx, src/lib/commands.ts</files>
  <action>
Currently, when a command is executed, only the command object is passed. We need to also pass any arguments the user typed after the command name.

1. Parse the query to extract command name and arguments:
```typescript
// In handleSubmit:
const handleSubmit = () => {
  if (filteredCommands.length > 0 && selectedIndex < filteredCommands.length) {
    const selectedCommand = filteredCommands[selectedIndex];
    if (selectedCommand) {
      // Extract arguments from query
      // Query might be "plan-phase 4" or just "plan-phase"
      const queryParts = query.trim().split(/\s+/);
      const args = queryParts.slice(1).join(' '); // Everything after command name

      onExecute(selectedCommand, showToast, args);
    }
  }
};
```

2. Update the `onExecute` callback signature to accept args:
```typescript
onExecute: (command: Command, showToast: (msg: string, type?: ToastType) => void, args?: string) => void;
```

3. Update App.tsx to pass args through to command execution:
- In `handleCommandSelect`, store args along with pending command
- Pass args to `addBackgroundJob` or `spawnOpencodeSession`

4. Update commands.ts Command interface:
```typescript
export interface Command {
  name: string;
  description: string;
  key?: string;
  action: (showToast: (msg: string, type?: ToastType) => void, args?: string) => void;
  queueable?: boolean;
}
```

5. Update stub actions and real actions to accept args parameter.

For background jobs, the args should be included in the prompt:
```typescript
// In addBackgroundJob:
addBackgroundJob(`${commandName} ${args}`.trim());
```

For spawn session:
```typescript
spawnOpencodeSession(`/gsd:${commandName} ${args}`.trim());
```
  </action>
  <verify>
1. `bun run typecheck` passes
2. Open palette, type "plan-phase 4", press Enter
3. The execution should include "4" as the argument
4. Toast or execution mode prompt should show the full command with args
  </verify>
  <done>Commands receive typed arguments; background jobs and spawn sessions include arguments in prompts.</done>
</task>

</tasks>

<verification>
1. `bun run typecheck` passes
2. `bun run lint` passes
3. Tab completion works: partial input + Tab = completed command name + space
4. Arguments are passed through: "plan-phase 4" executes with "4" as argument
5. Background jobs show command with arguments in job list
</verification>

<success_criteria>
- Tab key autocompletes command name with trailing space
- User can type arguments after completion
- Arguments flow through to command execution
- Background jobs and spawn sessions include arguments
</success_criteria>

<output>
After completion, create `.planning/phases/04-opencode-integration/04-07-SUMMARY.md`
</output>
