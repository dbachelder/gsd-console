---
phase: 01-core-tui
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - tsconfig.json
  - biome.json
  - lefthook.yml
  - commitlint.config.js
  - bunfig.toml
  - src/lib/types.ts
  - src/lib/parser.ts
  - src/lib/icons.ts
  - src/hooks/useGsdData.ts
  - src/cli.tsx
  - src/app.tsx
  - src/components/layout/TabLayout.tsx
  - src/components/layout/Header.tsx
  - src/components/layout/Footer.tsx
  - README.md
autonomous: true

must_haves:
  truths:
    - "Running `bun run dev` starts the TUI without errors"
    - "TypeScript compilation succeeds with strict mode"
    - "Biome linting passes with no errors"
    - "Pre-commit hooks run on git commit"
    - "GSD planning docs are parsed into typed data structures"
  artifacts:
    - path: "package.json"
      provides: "Project configuration with all dependencies"
      contains: "ink"
    - path: "src/lib/types.ts"
      provides: "TypeScript interfaces for GSD data"
      exports: ["Phase", "Todo", "GsdData", "ProjectState"]
    - path: "src/lib/parser.ts"
      provides: "Markdown/YAML parsing utilities"
      exports: ["parseRoadmap", "parseState", "parseTodos"]
    - path: "src/hooks/useGsdData.ts"
      provides: "React hook for loading planning docs"
      exports: ["useGsdData"]
    - path: "src/app.tsx"
      provides: "Main app component with layout structure"
      min_lines: 30
  key_links:
    - from: "src/app.tsx"
      to: "src/hooks/useGsdData.ts"
      via: "hook import and invocation"
      pattern: "useGsdData"
    - from: "src/hooks/useGsdData.ts"
      to: "src/lib/parser.ts"
      via: "parser function calls"
      pattern: "parse(Roadmap|State|Todos)"
---

<objective>
Set up the GSD Status TUI project infrastructure and create core data parsing layer.

Purpose: Establish a working Bun + Ink + TypeScript project with proper tooling (Biome linting, Lefthook git hooks, Bun tests) and the foundational layer for loading and parsing GSD planning documents.

Output: A runnable (but minimal) TUI app that loads planning docs and displays a basic layout skeleton.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md
@.planning/phases/01-core-tui/01-CONTEXT.md
@.planning/phases/01-core-tui/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Initialize Bun project with dependencies and tooling</name>
  <files>
    - package.json
    - tsconfig.json
    - biome.json
    - lefthook.yml
    - commitlint.config.js
    - bunfig.toml
  </files>
  <action>
Initialize a new Bun project in the repo root and configure all development tooling.

1. Run `bun init` to create package.json (accept defaults, entry point: src/cli.tsx)

2. Install dependencies:
   ```bash
   bun add ink react @inkjs/ui gray-matter
   bun add -d typescript @types/react @types/node @biomejs/biome lefthook @commitlint/cli @commitlint/config-conventional
   ```

3. Create tsconfig.json with strict mode:
   - target: ES2022, module: ESNext, moduleResolution: bundler
   - strict: true, noImplicitAny: true, strictNullChecks: true
   - jsx: react-jsx, jsxImportSource: react
   - include: ["src/**/*"], outDir: "dist"

4. Create biome.json (use config from RESEARCH.md):
   - Enable linting with recommended rules
   - noUnusedImports: error, noUnusedVariables: error
   - Formatter: tabs, width 100, single quotes, semicolons always

5. Create lefthook.yml:
   - pre-commit: parallel biome check (with --write and stage_fixed) + typecheck
   - commit-msg: commitlint validation
   - Run `bunx lefthook install` to set up hooks

6. Create commitlint.config.js extending @commitlint/config-conventional

7. Create bunfig.toml with test configuration:
   - coverage: true, threshold 0.8
   - coverageReporter: ["text", "lcov"]

8. Update package.json scripts:
   - "dev": "bun --watch src/cli.tsx"
   - "start": "bun src/cli.tsx"
   - "lint": "biome check ."
   - "lint:fix": "biome check --write ."
   - "typecheck": "tsc --noEmit"
   - "test": "bun test"
   - "test:coverage": "bun test --coverage"
  </action>
  <verify>
    - `bun run typecheck` passes
    - `bun run lint` passes (may need to create placeholder src/cli.tsx first)
    - `bunx lefthook run pre-commit` executes without errors
  </verify>
  <done>Project has all tooling configured: Bun, TypeScript strict, Biome linting, Lefthook hooks, Bun test with coverage.</done>
</task>

<task type="auto">
  <name>Task 2: Create types, parser, and data loading hook</name>
  <files>
    - src/lib/types.ts
    - src/lib/parser.ts
    - src/lib/icons.ts
    - src/hooks/useGsdData.ts
  </files>
  <action>
Create the core data layer for parsing GSD planning documents.

1. Create src/lib/types.ts with TypeScript interfaces:
   ```typescript
   // Phase status types
   type PhaseStatus = 'not-started' | 'in-progress' | 'complete' | 'blocked';

   // Phase indicators (derived from file existence/content)
   interface PhaseIndicators {
     hasContext: boolean;    // CONTEXT.md exists
     hasPlan: boolean;       // PLAN.md exists
     hasResearch: boolean;   // RESEARCH.md exists
     needsVerification: boolean; // Phase complete but not verified
   }

   interface Phase {
     number: number;          // 1, 2, 3...
     name: string;            // "Core TUI"
     goal: string;            // From roadmap
     status: PhaseStatus;
     requirements: string[];  // Requirement IDs (DISP-01, etc.)
     successCriteria: string[];
     indicators: PhaseIndicators;
     plansTotal: number;
     plansComplete: number;
   }

   interface Todo {
     id: string;
     text: string;
     completed: boolean;
     source?: string;        // File path where todo was found
     phase?: number;         // Related phase if any
   }

   interface ProjectState {
     currentPhase: number;
     totalPhases: number;
     projectName: string;
     coreValue: string;
     progressPercent: number;
   }

   interface GsdData {
     phases: Phase[];
     todos: Todo[];
     state: ProjectState;
     loading: boolean;
     error: Error | null;
   }
   ```

2. Create src/lib/parser.ts with parsing functions:
   - parseRoadmap(content: string): Phase[] - Parse ROADMAP.md markdown
     - Extract phase list from "## Phases" section
     - Extract phase details from "### Phase N:" sections
     - Parse success criteria, requirements, plan counts
   - parseState(content: string): ProjectState - Parse STATE.md
     - Extract current phase, progress, project name
   - parseTodos(stateContent: string): Todo[] - Extract todos from STATE.md pending section
   - scanPhaseDirectory(phaseDir: string): PhaseIndicators - Check which files exist

   Use gray-matter only if files have YAML frontmatter; otherwise parse markdown directly.
   Handle missing files gracefully (return sensible defaults).

3. Create src/lib/icons.ts with status indicator emojis and colors:
   ```typescript
   // Status icons (using Unicode for terminal compatibility)
   export const icons = {
     complete: '‚úì',      // Green
     inProgress: '‚óê',    // Yellow
     notStarted: '‚óã',    // Dim
     blocked: '‚úó',       // Red
     hasContext: 'üìã',
     hasPlan: 'üìù',
     hasResearch: 'üî¨',
     needsVerification: '‚ö†',
   };

   // Color wrappers for Ink Text component
   export const statusColors = {
     complete: 'green',
     inProgress: 'yellow',
     notStarted: 'gray',
     blocked: 'red',
   };
   ```

4. Create src/hooks/useGsdData.ts:
   - Accept planningDir path (default: '.planning')
   - Use useState for data, loading, error
   - Use useEffect to load and parse all files on mount:
     - Read ROADMAP.md, STATE.md, REQUIREMENTS.md
     - Scan phases/ directory for phase indicators
     - Call parser functions and assemble GsdData
   - Handle errors gracefully (set error state, don't crash)
   - Export the hook for use in components
  </action>
  <verify>
    - `bun run typecheck` passes with all new types
    - Create a simple test: `bun test src/lib/parser.test.ts` that imports parser and types
  </verify>
  <done>Types defined for Phase, Todo, ProjectState, GsdData. Parser functions extract data from planning docs. useGsdData hook loads all data on mount.</done>
</task>

<task type="auto">
  <name>Task 3: Create app shell with layout components</name>
  <files>
    - src/cli.tsx
    - src/app.tsx
    - src/components/layout/TabLayout.tsx
    - src/components/layout/Header.tsx
    - src/components/layout/Footer.tsx
    - README.md
  </files>
  <action>
Create the main app structure with Ink components.

1. Create src/cli.tsx (entry point):
   - Add shebang: #!/usr/bin/env bun
   - Parse CLI args using meow (or simple process.argv parsing):
     - `--only, -o`: Show only one view (roadmap|phase|todos)
     - `--phase, -p`: Phase number for --only phase mode (default: 1)
     - `--dir, -d`: Path to .planning directory (default: .planning)
   - Call render(<App flags={flags} />) from ink

2. Create src/app.tsx (main component):
   - Import useGsdData hook to load planning data
   - Import TabLayout, Header, Footer
   - Handle loading state (show spinner from @inkjs/ui)
   - Handle error state (show error message)
   - Render layout structure:
     ```tsx
     <Box flexDirection="column" height="100%">
       <Header projectName={data.state.projectName} />
       <TabLayout data={data} flags={flags} />
       <Footer />
     </Box>
     ```

3. Create src/components/layout/Header.tsx:
   - Display project name and "GSD Status" title
   - Show current phase indicator (e.g., "Phase 2/4")
   - Add progress bar showing overall completion (use @inkjs/ui ProgressBar or custom)
   - Use Box with borderStyle for visual separation

4. Create src/components/layout/TabLayout.tsx:
   - Manage active tab state: 'roadmap' | 'phase' | 'todos'
   - If flags.only is set, render only that view (no tabs)
   - Otherwise render tab bar with [1] Roadmap [2] Phase [3] Todos
   - Highlight active tab
   - Render placeholder content for each tab (actual views in Plan 02):
     - Roadmap: "<Roadmap placeholder - {N} phases>"
     - Phase: "<Phase {N} placeholder>"
     - Todos: "<Todos placeholder - {N} items>"
   - Use useFocusManager for Tab key navigation between tabs

5. Create src/components/layout/Footer.tsx:
   - Display keybinding hints: "Tab: switch | 1/2/3: jump | q: quit | ?: help"
   - Use dimColor for subtle appearance
   - Adjust hints based on current context (e.g., in --only mode, no tab switching)

6. Create README.md:
   - Project title and description
   - Installation: `bun install`
   - Usage: `bun run dev`, `bun start`, CLI flags
   - Development: linting, testing, pre-commit hooks
   - Project structure overview
   - Keep it concise (not enterprise documentation)
  </action>
  <verify>
    - `bun run dev` starts the TUI and displays header, placeholder content, and footer
    - q key exits the app cleanly
    - Tab key cycles through tabs (visible in tab bar highlight)
    - 1/2/3 keys jump to respective tabs
    - --only roadmap flag shows only roadmap view (no tab bar)
  </verify>
  <done>App shell renders with Header showing project name and progress, TabLayout with tab switching, and Footer with keybinding hints. Entry point parses CLI args.</done>
</task>

</tasks>

<verification>
After completing all tasks:

1. Project runs: `bun run dev` displays the TUI with header, tabs, footer
2. Tooling works:
   - `bun run lint` passes
   - `bun run typecheck` passes
   - Git commit triggers pre-commit hooks
3. Data loads: App shows project name and phase count from parsed planning docs
4. Navigation works: Tab, 1/2/3, and q keys function as expected
5. CLI flags work: `bun start --only roadmap` shows roadmap-only mode
</verification>

<success_criteria>
- Project structure matches RESEARCH.md recommendations
- All TypeScript strict checks pass
- Biome linting passes with configured rules
- Pre-commit hooks installed and functional
- GSD planning docs parsed into typed data structures
- TUI renders basic layout with header, tabs, footer
- Keyboard navigation (Tab, 1/2/3, q) works
- README documents usage and development workflow
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-tui/01-01-SUMMARY.md`
</output>
