# Phase 03.1: UI polish - Research

**Researched:** 2025-01-24
**Domain:** React/Ink TUI UI refinement
**Confidence:** HIGH

## Summary

Research focused on UI refinement patterns for Ink-based terminal UI applications. Key areas investigated:
1. Sticky footer layout using Flexbox patterns
2. Tab styling improvements with Text component properties
3. Plan file parsing and display integration
4. State preservation across tab navigation
5. Header sizing consistency
6. Scroll position tracking

**Primary recommendation:** Use Ink's Flexbox layout system with flexGrow patterns and lift state to parent components to preserve state across tab switches without unmounting.

## Standard Stack

### Core
| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| Ink | 6.6.0 | React TUI renderer with Flexbox layout | Already in use, provides Box/Text components, flex layout, useRef/useState patterns |
| React | 19.2.3 | Component state management and lifecycle | Already in use, standard hooks for state persistence |

### Supporting
| Library | Version | Purpose | When to Use |
|---------|---------|---------|-------------|
| gray-matter | 4.0.3 | Parse frontmatter from markdown files | Already in use for reading plan files |
| @nozbe/microfuzz | 1.0.0 | Fuzzy search (for future enhancements) | Already installed, 2KB size |

### Alternatives Considered
| Instead of | Could Use | Tradeoff |
|------------|-----------|----------|
| Ink Flexbox | Manual layout | Flexbox is built-in, handles terminals with Yoga engine |
| useState in components | Zustand/Jotai | Overkill for session-only state, useState with parent lifting is sufficient |
| Custom scroll tracking | useVimNav scrollOffset | useVimNav already provides scrollOffset, just need to use it |

**Installation:**
```bash
# No new packages needed
# All required libraries are already installed
```

## Architecture Patterns

### Recommended Component Structure for State Preservation

```
App.tsx (lifted state)
├── state per tab:
│   ├── tabStates: Record<'roadmap' | 'phase' | 'todos', {
│   │     expandedPhases: Set<number> | null
│   │     detailLevel: number
│   │     scrollOffset: number
│   │     selectedIndex: number
│   │   // Tab-specific view settings
│   │   }>
│   └── currentTab: 'roadmap' | 'phase' | 'todos'
├── components/
│   ├── layout/
│   │   ├── Footer.tsx (sticky with flexGrow)
│   │   ├── Header.tsx (fixed sizing)
│   │   └── TabLayout.tsx (preserves tab state)
│   ├── phase/
│   │   ├── PhaseView.tsx (shows plans inline)
│   │   └── PlanSummary.tsx (NEW: displays plan metadata)
│   ├── roadmap/
│   │   └── RoadmapView.tsx (uses tab-specific state)
│   └── todos/
│       └── TodosView.tsx (uses tab-specific state)
└── hooks/
    ├── useTabState.ts (NEW: manages per-tab state)
    └── useVimNav.ts (existing, provides scrollOffset)
```

### Pattern 1: Sticky Footer with Flexbox

**What:** Use Ink's Flexbox layout with flexGrow on content area to push footer to bottom
**When to use:** When footer should stay at bottom of viewport regardless of content height
**Example:**
```typescript
// Source: https://github.com/vadimdemedes/ink (Box flexGrow documentation)
import { Box, Text } from 'ink';

function App() {
  return (
    <Box flexDirection="column" height={20}>
      {/* Header - fixed height */}
      <Box height={3}>
        <Text>Header</Text>
      </Box>

      {/* Content - grows to fill space */}
      <Box flexDirection="column" flexGrow={1}>
        <Text>Main content area</Text>
      </Box>

      {/* Footer - no flexGrow, sits at bottom */}
      <Box>
        <Text>Footer hints</Text>
      </Box>
    </Box>
  );
}
```

### Pattern 2: State Persistence Across Tabs

**What:** Lift state to parent component so child views don't unmount/remount on tab switch
**When to use:** When multiple tabs should preserve their individual scroll positions, selections, and toggle states
**Example:**
```typescript
// Custom hook for per-tab state management
import { useState, useCallback, useRef } from 'react';

type TabState = {
  expandedPhases: Set<number>;
  detailLevel: number;
  scrollOffset: number;
  selectedIndex: number;
};

type TabId = 'roadmap' | 'phase' | 'todos';

export function useTabState<T extends TabId>(initialTab: T) {
  const [currentTab, setCurrentTab] = useState<T>(initialTab);

  // Use ref to store tab-specific state to avoid re-renders
  const tabStates = useRef<Partial<Record<T, TabState>>>({});

  const getTabState = useCallback((tab: T): TabState => {
    return tabStates.current[tab] ?? {
      expandedPhases: new Set(),
      detailLevel: 1,
      scrollOffset: 0,
      selectedIndex: 0,
    };
  }, []);

  const setTabState = useCallback((tab: T, state: Partial<TabState>) => {
    tabStates.current[tab] = {
      ...getTabState(tab),
      ...state,
    };
  }, [getTabState]);

  return {
    currentTab,
    setCurrentTab,
    getTabState,
    setTabState,
  };
}
```

### Pattern 3: Plan File Parsing and Display

**What:** Read PLAN.md files from phase directories, parse gray-matter frontmatter, display metadata
**When to use:** When showing plan summaries in phase tab without requiring editor integration
**Example:**
```typescript
import { readFileSync, existsSync } from 'node:fs';
import { join } from 'node:path';
import matter from 'gray-matter';

interface PlanMetadata {
  summary?: string;
  wave?: number;
  taskCount?: number;
  plan: number;
  type: string;
}

export function parsePlanFile(phaseDir: string, phaseNumber: number, planNumber: number): PlanMetadata | null {
  const paddedNumber = phaseNumber < 10 ? `0${phaseNumber}` : `${phaseNumber}`;
  const planFilename = `${paddedNumber}-${planNumber.toString().padStart(2, '0')}-PLAN.md`;
  const planPath = join(phaseDir, planFilename);

  if (!existsSync(planPath)) {
    return null;
  }

  const content = readFileSync(planPath, 'utf-8');
  const { data } = matter(content);

  return data as PlanMetadata;
}
```

### Anti-Patterns to Avoid

- **Storing tab state in local component state:** Causes state loss when tabs unmount/remount. Instead: Lift to parent with useTabState pattern.
- **Using marginTop for footer positioning:** Footer won't stick to bottom if content grows. Instead: Use flexGrow on content, no flexGrow on footer.
- **Re-reading plan files on every render:** Expensive I/O. Instead: Read once in useEffect, cache in state.
- **Ignoring scrollOffset from useVimNav:** Hook provides it but current views don't use it for actual rendering. Instead: Implement virtual scrolling or at least track offset.

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Footer positioning math | Calculate content height, manually position footer | Ink flexGrow handles flexbox layout automatically, terminal size agnostic |
| State management library | Zustand, Jotai, Redux | Session-only state doesn't need global store, useState + useRef is sufficient |
| Custom markdown parser | Manual regex parsing | gray-matter already handles frontmatter, handles edge cases |
| Scroll calculation | Manual offset math | useVimNav already provides scrollOffset state, just use it |

**Key insight:** Ink's Flexbox layout (via Yoga engine) handles terminal layout dynamically - custom calculations break when terminal resizes.

## Common Pitfalls

### Pitfall 1: State Loss on Tab Switch

**What goes wrong:** Setting state in child components (RoadmapView, PhaseView, TodosView) means state resets when switching tabs because components unmount/remount.

**Why it happens:** React's component lifecycle - unmounted components lose their useState values.

**How to avoid:** Lift state to parent (App.tsx or TabLayout) using custom useTabState hook that stores state per-tab in a ref.

**Warning signs:** Toggle states reset when switching tabs, scroll position jumps to top, selection resets to index 0.

### Pitfall 2: Footer Not Sticking to Bottom

**What goes wrong:** Footer appears after content, but moves up when content area is short or down when content is long.

**Why it happens:** Missing flexGrow on content area means flex container doesn't distribute space properly.

**How to avoid:** Use `flexGrow={1}` on main content Box, ensure parent Box has `flexDirection="column"` and sufficient height.

**Warning signs:** Footer spacing varies between tabs with different content lengths.

### Pitfall 3: Header Size Fluctuates

**What goes wrong:** Header height changes based on what's displayed in main content area, causing layout jitter.

**Why it happens:** Header uses dynamic sizing or margin-bottom that depends on sibling content.

**How to avoid:** Fix header height using explicit `height` prop or consistent padding/margins, independent of content.

**Warning signs:** Visual "jumping" when switching between roadmap/phase/todos tabs.

### Pitfall 4: Inactive Tab Visual Indication Too Subtle

**What goes wrong:** User can't tell which tab is active, looks washed out.

**Why it happens:** Only dimColor on inactive tabs, no visual hierarchy.

**How to avoid:** Use backgroundColor, bold, or underlines for active tab. Dim inactive tabs but keep them readable.

**Warning signs:** Users ask "which tab am I on?" or hesitate before switching.

### Pitfall 5: Re-reading Files on Every Render

**What goes wrong:** Performance degradation, unnecessary I/O operations.

**Why it happens:** File reading inside render() or useEffect without proper dependencies.

**How to avoid:** Read files once in useEffect with proper dependency array, cache result in state. Use refs for file path checking.

**Warning signs:** Lag when switching tabs, high CPU usage during typing.

## Code Examples

Verified patterns from official sources:

### Sticky Footer Layout

```typescript
// Source: https://github.com/vadimdemedes/ink (Box flexGrow, Spacer components)
import { Box, Text, Spacer } from 'ink';

export function MainLayout() {
  return (
    <Box flexDirection="column" height="100%">
      <Box height={3}>
        <Text>Fixed Header</Text>
      </Box>

      {/* Content area - fills available space */}
      <Box flexDirection="column" flexGrow={1}>
        <Text>Dynamic content here</Text>
      </Box>

      {/* Alternative: Use Spacer to push footer to bottom */}
      {/* <Spacer /> */}
      <Box>
        <Text>Sticky Footer</Text>
      </Box>
    </Box>
  );
}
```

### Tab Styling with Better Visual Hierarchy

```typescript
// Source: Ink Text component API (color, bold, underline, dimColor)
import { Box, Text } from 'ink';

interface TabBarProps {
  activeTab: string;
  tabs: Array<{ id: string; label: string; key: string }>;
}

export function TabBar({ activeTab, tabs }: TabBarProps) {
  return (
    <Box marginBottom={1} paddingX={1}>
      {tabs.map((tab, index) => (
        <Box key={tab.id}>
          {index > 0 && <Text dimColor> | </Text>}
          {activeTab === tab.id ? (
            // Active tab: bold with background color
            <Text bold backgroundColor="gray" color="white" underline>
              {' '}{tab.key}{' '}{tab.label}{' '}
            </Text>
          ) : (
            // Inactive tab: dimmed but readable
            <Text dimColor>
              {' '}{tab.key}{' '}{tab.label}{' '}
            </Text>
          )}
        </Box>
      ))}
    </Box>
  );
}
```

### Reading Plan Metadata

```typescript
// Source: gray-matter library + existing parser pattern
import { readFileSync, existsSync } from 'node:fs';
import { join } from 'node:path';
import matter from 'gray-matter';

interface PlanMetadata {
  summary?: string; // From <objective> section
  wave?: number;     // From frontmatter
  plan: number;       // Plan number from frontmatter
  type: string;       // From frontmatter
}

/**
 * Read and parse a PLAN.md file from phase directory
 */
export function readPlanMetadata(
  planningDir: string,
  phaseNumber: number,
  planNumber: number
): PlanMetadata | null {
  // Find phase directory
  const paddedNumber = phaseNumber < 10 ? `0${phaseNumber}` : `${phaseNumber}`;
  const phaseDir = join(planningDir, 'phases', `${paddedNumber}-*`);

  // Construct plan filename: 03-01-PLAN.md, 03-02-PLAN.md, etc.
  const planFilename = `${paddedNumber}-${planNumber.toString().padStart(2, '0')}-PLAN.md`;
  const planPath = join(phaseDir, planFilename);

  if (!existsSync(planPath)) {
    return null;
  }

  try {
    const content = readFileSync(planPath, 'utf-8');
    const { data, content } = matter(content);

    // Extract summary from <objective> section if present in frontmatter
    const metadata = data as PlanMetadata;

    // Parse content for objective summary if not in frontmatter
    if (!metadata.summary && content.includes('<objective>')) {
      const match = /<objective>([\s\S]*?)<\/objective>/s.exec(content);
      if (match?.[1]) {
        const objectiveLines = match[1].trim().split('\n');
        metadata.summary = objectiveLines.find(line => line.trim().startsWith('Purpose:'))?.replace('Purpose:', '').trim();
      }
    }

    return metadata;
  } catch {
    return null;
  }
}

/**
 * Get all plan metadata for a phase
 */
export function readAllPlansForPhase(
  planningDir: string,
  phaseNumber: number
): PlanMetadata[] {
  const paddedNumber = phaseNumber < 10 ? `0${phaseNumber}` : `${phaseNumber}`;
  const phaseDir = join(planningDir, 'phases', `${paddedNumber}-*`);

  // Find all plan files matching pattern XX-NN-PLAN.md
  // This requires readdir and filtering - implement in component
  return []; // Placeholder
}
```

### State Preservation with Custom Hook

```typescript
// Source: React patterns (useState, useRef, useCallback)
import { useState, useCallback, useRef } from 'react';

type TabId = 'roadmap' | 'phase' | 'todos';

interface TabState {
  // Roadmap-specific state
  expandedPhases?: Set<number>;
  showIndicators?: boolean;
  scrollOffset?: number;
  selectedIndex?: number;

  // Phase-specific state
  detailLevel?: number;

  // Todos-specific state
  showCompleted?: boolean;
  showDetail?: boolean;
}

export function useTabState(initialTab: TabId = 'roadmap') {
  const [currentTab, setCurrentTab] = useState<TabId>(initialTab);

  // Use ref to persist state across renders without causing re-renders
  const stateRef = useRef<Partial<Record<TabId, TabState>>>({});

  // Get state for a specific tab, with defaults
  const getState = useCallback((tab: TabId): TabState => {
    return stateRef.current[tab] || {};
  }, []);

  // Update state for a specific tab
  const setState = useCallback((tab: TabId, updates: Partial<TabState>) => {
    stateRef.current[tab] = {
      ...getState(tab),
      ...updates,
    };
  }, [getState]);

  // Switch tab (preserving current tab's state first)
  const switchTab = useCallback((newTab: TabId) => {
    setCurrentTab(newTab);
  }, []);

  return {
    currentTab,
    switchTab,
    getState,
    setState,
  };
}

// Usage in component:
export function TabLayout() {
  const { currentTab, switchTab, getState, setState } = useTabState('roadmap');

  // Save state when leaving a tab
  const handleTabChange = useCallback((newTab: TabId) => {
    setState(currentTab, {
      expandedPhases: localExpandedPhases,
      detailLevel: localDetailLevel,
      scrollOffset: localScrollOffset,
      selectedIndex: localSelectedIndex,
    });
    switchTab(newTab);
  }, [currentTab, localExpandedPhases, localDetailLevel, localScrollOffset, localSelectedIndex, switchTab, setState]);

  // Restore state when entering a tab
  useEffect(() => {
    const savedState = getState(currentTab);
    if (savedState.expandedPhases) setLocalExpandedPhases(savedState.expandedPhases);
    if (savedState.detailLevel !== undefined) setLocalDetailLevel(savedState.detailLevel);
    if (savedState.scrollOffset !== undefined) setLocalScrollOffset(savedState.scrollOffset);
    if (savedState.selectedIndex !== undefined) setLocalSelectedIndex(savedState.selectedIndex);
  }, [currentTab, getState]);

  // ... rest of component
}
```

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|----------------|--------------|--------|
| Manual footer positioning with marginTop | flexGrow={1} on content area | Initial Ink release | Dynamic terminal sizing handled automatically |
| Component-local state | Parent-lifted state with useTabState | Early React development | Preserves state across navigation |
| Basic tab styling | Bold + background color for active tab | This project | Better visual hierarchy |
| No plan file display | Inline plan summary in PhaseView | Phase 3.1 | Shows plan metadata without editor |

**Deprecated/outdated:**
- Direct coordinate-based positioning: Ink's Flexbox handles layout automatically
- State persistence via localStorage: Session-only state requested, React state is sufficient

## Open Questions

1. **Plan file navigation depth**
   - What we know: Phase tab should show plans with summary and task count
   - What's unclear: Should users navigate to individual plans? Navigate to success criteria/goal details?
   - Recommendation: Start with plan list summary only, navigation to plan details left to Claude's discretion (per CONTEXT.md)

2. **Scroll position implementation**
   - What we know: useVimNav provides scrollOffset, but views don't implement actual virtual scrolling
   - What's unclear: Should we implement full virtual scrolling or just track offset for preservation?
   - Recommendation: Track and restore scrollOffset per-tab (minimal implementation). Full virtual scrolling deferred unless needed.

3. **Help bar toggle hotkey**
   - What we know: Help bar needs toggle hotkey, doesn't need to be documented in help bar itself
   - What's unclear: Which hotkey? 'h' (help), '/' (search), or other?
   - Recommendation: Use 'h' (help toggle) - intuitive and doesn't conflict with existing bindings (j/k, :, q, ?, e)

## Sources

### Primary (HIGH confidence)
- `/vadimdemedes/ink` - Box flexGrow properties, Flexbox layout, Spacer component, Text styling (color, bold, dimColor, backgroundColor)
- `/vadimdemedes/ink` - useInput hook, useEffect lifecycle, useState patterns
- `/vadimdemedes/ink` - measureElement for dimension detection
- Existing codebase: `src/hooks/useVimNav.ts` - scrollOffset state already available
- Existing codebase: `src/lib/parser.ts` - readPlanningFile with gray-matter

### Secondary (MEDIUM confidence)
- gray-matter documentation: Frontmatter parsing from markdown files
- React patterns for state lifting and refs

### Tertiary (LOW confidence)
- None - all findings verified from official sources or existing codebase

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - Ink 6.6.0 and React 19.2.3 are verified in package.json
- Architecture: HIGH - Patterns from official Ink documentation and existing codebase analysis
- Pitfalls: HIGH - Identified from reviewing current implementation and known React lifecycle issues

**Research date:** 2025-01-24
**Valid until:** 2025-02-23 (30 days - stable library ecosystem)
