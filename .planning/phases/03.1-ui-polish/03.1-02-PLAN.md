---
phase: 03.1-ui-polish
plan: 02
type: execute
wave: 2
depends_on: ["03.1-01"]
files_modified:
  - src/hooks/useTabState.ts
  - src/components/layout/TabLayout.tsx
  - src/components/phase/PhaseView.tsx
  - src/components/roadmap/RoadmapView.tsx
  - src/components/todos/TodosView.tsx
autonomous: true

must_haves:
  truths:
    - "Selected phase is preserved when switching between tabs"
    - "Detail level toggle state is preserved when switching tabs"
    - "Scroll position is preserved when switching back to a tab"
    - "State persists for the current session only (not across TUI restarts)"
  artifacts:
    - path: "src/hooks/useTabState.ts"
      provides: "Custom hook for per-tab state storage"
      exports: ["useTabState"]
    - path: "src/components/layout/TabLayout.tsx"
      provides: "Wiring for state persistence in tab switching"
      exports: ["TabLayout"]
  key_links:
    - from: "src/components/layout/TabLayout.tsx"
      to: "src/hooks/useTabState.ts"
      via: "Hook import and invocation"
      pattern: "useTabState"
    - from: "src/components/layout/TabLayout.tsx"
      to: "src/components/phase/PhaseView.tsx"
      via: "State prop passing"
      pattern: "detailLevel.*onDetailLevelChange"
---

<objective>
Implement tab state persistence to preserve selected phase, detail level toggle, and scroll position when switching between tabs.

Purpose: User's current view state (selected phase, detail level, scroll position) should persist when switching between tabs (roadmap, phase, todos) for the current session.
Output: New useTabState hook and state persistence wiring in views
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03.1-ui-polish/03.1-CONTEXT.md
@.planning/phases/03.1-ui-polish/03.1-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useTabState hook for per-tab state storage</name>
  <files>src/hooks/useTabState.ts</files>
  <action>
Create new src/hooks/useTabState.ts with per-tab state management:

```tsx
import { useCallback, useState } from 'react';

export type TabId = 'roadmap' | 'phase' | 'todos';

export interface TabState {
  selectedPhaseNumber?: number;
  detailLevel?: number;  // 1-3 for PhaseView
  scrollOffset?: number;
  selectedTodoId?: string;
}

export function useTabState() {
  const [tabState, setTabState] = useState<Record<TabId, TabState>>({
    roadmap: { selectedPhaseNumber: undefined, detailLevel: undefined, scrollOffset: 0 },
    phase: { selectedPhaseNumber: undefined, detailLevel: 1, scrollOffset: 0 },
    todos: { selectedTodoId: undefined, detailLevel: undefined, scrollOffset: 0 },
  });

  const setTab = useCallback((tab: TabId, state: Partial<TabState>) => {
    setTabState(prev => ({
      ...prev,
      [tab]: { ...prev[tab], ...state },
    }));
  }, []);

  const getTab = useCallback((tab: TabId): TabState => {
    return tabState[tab] ?? {};
  }, [tabState]);

  return { tabState, setTab, getTab };
}
```

DO NOT use LocalStorage (per CONTEXT.md: "Session only (no persistence across TUI restarts)").
DO use React useState for session-only persistence (per RESEARCH.md state persistence pattern).
</action>
  <verify>
  Verify hook compiles with `npx tsc --noEmit`
  </verify>
  <done>useTabState hook created with per-tab state storage for selected phase, detail level, and scroll offset</done>
</task>

<task type="auto">
  <name>Task 2: Wire up state persistence in TabLayout and views</name>
  <files>src/components/layout/TabLayout.tsx, src/components/phase/PhaseView.tsx, src/components/roadmap/RoadmapView.tsx, src/components/todos/TodosView.tsx</files>
  <action>
Wire state persistence in TabLayout and update views to accept/emit state changes:

**TabLayout.tsx changes:**
1. Import and use useTabState hook
2. Pass state props to views (detailLevel, onDetailLevelChange, scrollOffset)
3. Store state on tab unmount (cleanup effect)
4. Restore state on tab mount (effect with activeTab dependency)

```tsx
import { useTabState } from '../../hooks/useTabState.ts';

// In TabLayout component:
const { getTab, setTab } = useTabState();
const tabState = getTab(activeTab);

// Save state on unmount
useEffect(() => {
  return () => {
    // Store current scroll offset when tab unmounts
    // Views will emit scroll offset changes via onScrollOffsetChange
  };
}, [activeTab]);

// PhaseView gets:
<PhaseView
  detailLevel={tabState.detailLevel ?? 1}
  onDetailLevelChange={(level) => setTab('phase', { detailLevel: level })}
  selectedPhaseNumber={tabState.selectedPhaseNumber ?? selectedPhaseNumber}
  onPhaseSelect={(num) => {
    onPhaseSelect(num);
    setTab('phase', { selectedPhaseNumber: num });
  }}
/>
```

**PhaseView.tsx changes:**
1. Remove internal detailLevel state (now controlled via prop)
2. Add onDetailLevelChange prop
3. Add scrollOffset and onScrollOffsetChange props for scroll tracking

```tsx
interface PhaseViewProps {
  // ... existing props
  detailLevel: number;
  onDetailLevelChange: (level: number) => void;
  scrollOffset?: number;
  onScrollOffsetChange?: (offset: number) => void;
}

export function PhaseView({ ..., detailLevel, onDetailLevelChange }: PhaseViewProps) {
  // Remove: const [detailLevel, setDetailLevel] = useState<DetailLevel>(1);

  // Update toggle handler:
  useInput(
    (input) => {
      // ... other handlers
      if (input === 'd') {
        const newLevel = ((detailLevel % 3) + 1) as DetailLevel;
        onDetailLevelChange(newLevel);
      }
    },
    { isActive },
  );
```

**RoadmapView.tsx and TodosView.tsx changes:**
- Add scrollOffset and onScrollOffsetChange props (future scroll restoration)
- For now, accept the props but don't fully implement scroll tracking
- UseVimNav already provides scrollOffset state - wire it up in PhaseView first, then extend to other views

DO NOT persist state to disk or LocalStorage (session-only per CONTEXT.md).
DO save state in React state via useTabState hook.
</action>
  <verify>
  Run `bun run dev` and verify:
  1. Expand phase tab, toggle detail level with 'd' key
  2. Switch to roadmap tab, then back to phase tab
  3. Verify detail level is preserved (same as when you left)
  4. Select a different phase in roadmap
  5. Switch to todos, then back to roadmap
  6. Verify selected phase is preserved
  </verify>
  <done>State persistence wired in TabLayout and views - selected phase, detail level, and scroll position persist when switching tabs</done>
</task>

</tasks>

<verification>
Run TUI and verify state persistence:
1. Toggle detail level in phase view (d key)
2. Switch to roadmap tab
3. Switch back to phase tab - detail level should be preserved
4. Select phase 2 in roadmap
5. Switch to todos tab
6. Switch back to roadmap - phase 2 should still be selected
7. Verify no LocalStorage usage (state is session-only)
</verification>

<success_criteria>
- useTabState hook created with per-tab state storage
- Selected phase preserved when switching tabs
- Detail level toggle state preserved when switching tabs
- Scroll position tracking infrastructure in place (wired to views)
- State is session-only (no LocalStorage)
</success_criteria>

<output>
After completion, create `.planning/phases/03.1-ui-polish/03.1-02-SUMMARY.md`
</output>
