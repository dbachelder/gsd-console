---
phase: 03.1-ui-polish
plan: 02
type: execute
wave: 2
depends_on: ["03.1-01"]
files_modified:
  - src/hooks/useTabState.ts
  - src/components/layout/TabLayout.tsx
  - src/components/phase/PhaseView.tsx
  - src/components/roadmap/RoadmapView.tsx
  - src/components/todos/TodosView.tsx
autonomous: true

must_haves:
  truths:
    - "Selected phase is preserved when switching between tabs"
    - "Detail level toggle state is preserved when switching tabs"
    - "Scroll position is preserved when switching back to a tab"
    - "State persists for the current session only (not across TUI restarts)"
    - "Detail toggle is removed from roadmap view (repurposed for future /gsd-discuss-phase command)"
  artifacts:
    - path: "src/hooks/useTabState.ts"
      provides: "Custom hook for per-tab state storage"
      exports: ["useTabState"]
    - path: "src/components/layout/TabLayout.tsx"
      provides: "Wiring for state persistence in tab switching"
      exports: ["TabLayout"]
    - path: "src/components/roadmap/RoadmapView.tsx"
      provides: "Roadmap view without detail toggle"
      exports: ["RoadmapView"]
   key_links:
     - from: "src/components/layout/TabLayout.tsx"
       to: "src/hooks/useTabState.ts"
       via: "Hook import and invocation"
       pattern: "useTabState"
     - from: "src/components/layout/TabLayout.tsx"
       to: "src/components/phase/PhaseView.tsx"
       via: "State prop passing"
       pattern: "detailLevel.*onDetailLevelChange"
     - from: "src/components/phase/PhaseView.tsx"
       to: "src/hooks/useTabState.ts"
       via: "onScrollOffsetChange callback pattern"
       pattern: "onScrollOffsetChange"
     - from: "src/components/roadmap/RoadmapView.tsx"
       to: "(removed)"
       via: "Detail toggle removal"
       pattern: "(no longer present)"
---

<objective>
Implement tab state persistence to preserve selected phase, detail level toggle, and scroll position when switching between tabs.

Purpose: User's current view state (selected phase, detail level, scroll position) should persist when switching between tabs (roadmap, phase, todos) for the current session.
Output: New useTabState hook and state persistence wiring in views
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03.1-ui-polish/03.1-CONTEXT.md
@.planning/phases/03.1-ui-polish/03.1-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create useTabState hook for per-tab state storage</name>
  <files>src/hooks/useTabState.ts</files>
  <action>
Create new src/hooks/useTabState.ts with per-tab state management:

```tsx
import { useCallback, useState } from 'react';

export type TabId = 'roadmap' | 'phase' | 'todos';

export interface TabState {
  selectedPhaseNumber?: number;
  detailLevel?: number;  // 1-3 for PhaseView
  scrollOffset?: number;
  selectedTodoId?: string;
}

export function useTabState() {
  const [tabState, setTabState] = useState<Record<TabId, TabState>>({
    roadmap: { selectedPhaseNumber: undefined, detailLevel: undefined, scrollOffset: 0 },
    phase: { selectedPhaseNumber: undefined, detailLevel: 1, scrollOffset: 0 },
    todos: { selectedTodoId: undefined, detailLevel: undefined, scrollOffset: 0 },
  });

  const setTab = useCallback((tab: TabId, state: Partial<TabState>) => {
    setTabState(prev => ({
      ...prev,
      [tab]: { ...prev[tab], ...state },
    }));
  }, []);

  const getTab = useCallback((tab: TabId): TabState => {
    return tabState[tab] ?? {};
  }, [tabState]);

  return { tabState, setTab, getTab };
}
```

DO NOT use LocalStorage (per CONTEXT.md: "Session only (no persistence across TUI restarts)").
DO use React useState for session-only persistence (per RESEARCH.md state persistence pattern).
</action>
  <verify>
  Verify hook compiles with `npx tsc --noEmit`
  </verify>
  <done>useTabState hook created with per-tab state storage for selected phase, detail level, and scroll offset</done>
</task>

<task type="auto">
  <name>Task 2a: Wire useTabState hook in TabLayout</name>
  <files>src/components/layout/TabLayout.tsx</files>
  <action>
Wire useTabState hook in TabLayout to manage per-tab state:

1. Import useTabState hook at top of file
2. Call useTabState hook in TabLayout component body
3. Get current tab state with getTab(activeTab)
4. Store state on tab unmount using cleanup effect
5. Restore state on tab mount via effect with activeTab dependency

```tsx
import { useTabState } from '../../hooks/useTabState.ts';

// In TabLayout component:
const { getTab, setTab } = useTabState();
const tabState = getTab(activeTab);

// Save state on unmount (for scroll offset - emitted by views)
useEffect(() => {
  return () => {
    // Views will call setTab(activeTab, { scrollOffset }) via callbacks
    // No explicit storage needed here - views emit changes directly
  };
}, [activeTab, setTab]);

// State will be passed to views as props in Task 2b
```

DO NOT persist state to disk or LocalStorage (session-only per CONTEXT.md).
DO use useTabState for React state management only.
</action>
  <verify>
  Run `npx tsc --noEmit` to verify TabLayout compiles
  Run `bun run dev` and verify TabLayout loads without errors
  </verify>
  <done>useTabState hook imported and wired in TabLayout component</done>
</task>

<task type="auto">
  <name>Task 2b: Update views to accept/emit state props</name>
  <files>src/components/phase/PhaseView.tsx, src/components/roadmap/RoadmapView.tsx, src/components/todos/TodosView.tsx</files>
  <action>
Update views to accept controlled state props and emit state changes:

**PhaseView.tsx changes:**
1. Remove internal detailLevel useState (replace with controlled prop)
2. Add detailLevel prop (number, required)
3. Add onDetailLevelChange prop (callback, required)
4. Add scrollOffset prop (optional number)
5. Add onScrollOffsetChange prop (optional callback)

```tsx
interface PhaseViewProps {
  // ... existing props
  detailLevel: number;
  onDetailLevelChange: (level: number) => void;
  scrollOffset?: number;
  onScrollOffsetChange?: (offset: number) => void;
}

export function PhaseView({ ..., detailLevel, onDetailLevelChange }: PhaseViewProps) {
  // Remove: const [detailLevel, setDetailLevel] = useState<DetailLevel>(1);

  // Update toggle handler:
  useInput(
    (input) => {
      // ... other handlers
      if (input === 'd') {
        const newLevel = ((detailLevel % 3) + 1) as DetailLevel;
        onDetailLevelChange(newLevel);
      }
    },
    { isActive },
  );

  // Scroll offset tracking (optional - wire in next iteration):
  // onScrollOffsetChange?.(currentScrollOffset);
}
```

**RoadmapView.tsx changes:**
1. Add selectedPhaseNumber prop (optional number - for phase selection from roadmap)
2. Add onPhaseSelect prop (optional callback)
3. Add scrollOffset and onScrollOffsetChange props (optional - for future scroll restoration)

```tsx
interface RoadmapViewProps {
  // ... existing props
  selectedPhaseNumber?: number;
  onPhaseSelect?: (phaseNumber: number) => void;
  scrollOffset?: number;
  onScrollOffsetChange?: (offset: number) => void;
}

// Update phase selection handler:
const handlePhaseSelect = (phaseNumber: number) => {
  // ... existing logic
  onPhaseSelect?.(phaseNumber);
};
```

**TodosView.tsx changes:**
1. Add scrollOffset and onScrollOffsetChange props (optional - for future scroll restoration)
2. Accept props but don't implement scroll tracking yet (future work)

```tsx
interface TodosViewProps {
  // ... existing props
  scrollOffset?: number;
  onScrollOffsetChange?: (offset: number) => void;
}
```

DO NOT implement full scroll restoration yet - just add prop infrastructure.
DO preserve all existing view functionality.
DO use optional chaining for callbacks (onDetailLevelChange?.(), onScrollOffsetChange?.()).
</action>
  <verify>
  Run `npx tsc --noEmit` to verify all views compile
  Run `bun run dev` and verify all views load without errors
  </verify>
  <done>Views updated to accept controlled state props and emit state changes</done>
</task>

<task type="auto">
  <name>Task 3: Remove detail toggle from roadmap view</name>
  <files>src/components/roadmap/RoadmapView.tsx</files>
  <action>
Remove detail level toggle functionality from RoadmapView component by removing specific UI elements:

1. Remove detailLevel state variable from RoadmapView component:
   - Search for: `const [detailLevel, setDetailLevel] = useState<DetailLevel>(1);`
   - Search for: `type DetailLevel = 1 | 2 | 3;` (if defined locally)
   - Delete these lines and their type definitions

2. Remove 'd' key handler for detail level in useInput callback:
   - Search for: `if (input === 'd')` or `if (input.key === 'd')`
   - Find the detail level toggle handler block
   - Delete the entire if-block (typically 3-5 lines)

3. Remove detail level display/indicator from render() method:
   - Search for text patterns: `detailLevel`, `Detail:`, `Level:`, or any `[1]`, `[2]`, `[3]` indicators
   - Remove any Text or Box elements that display the detail level
   - Remove any conditional rendering based on detailLevel (e.g., `{detailLevel === 1 && ...}`)

4. Verify 'd' key is reserved (no handler remains):
   - Search RoadmapView.tsx for any remaining `'d'` references
   - Ensure no 'd' key handlers exist (key is now reserved for future /gsd-discuss-phase command)

The 'd' key should now do nothing in roadmap view (reserved for future use).

DO NOT remove detail toggle from PhaseView - that component should still have 'd' key functionality.
DO preserve all other roadmap keyboard navigation (arrows, Enter, etc.).
</action>
  <verify>
  Run `bun run dev` and verify:
  1. Navigate to roadmap tab
  2. Press 'd' key - nothing should happen (no detail toggle)
  3. Navigate to phase tab
  4. Press 'd' key - detail level should still toggle (1, 2, 3)
  5. Switch back to roadmap - verify 'd' key still does nothing
  6. Check roadmap UI - no detail level indicators visible
</verify>
  <done>Detail toggle removed from roadmap view - detailLevel state, 'd' key handler, and UI indicators all removed</done>
</task>

</tasks>

<verification>
Run TUI and verify state persistence:
1. Toggle detail level in phase view (d key)
2. Switch to roadmap tab
3. Switch back to phase tab - detail level should be preserved
4. Select phase 2 in roadmap
5. Switch to todos tab
6. Switch back to roadmap - phase 2 should still be selected
7. Verify no LocalStorage usage (state is session-only)
</verification>

<success_criteria>
- useTabState hook created with per-tab state storage
- Selected phase preserved when switching tabs
- Detail level toggle state preserved when switching tabs
- Scroll position tracking infrastructure in place (wired to views)
- State is session-only (no LocalStorage)
</success_criteria>

<output>
After completion, create `.planning/phases/03.1-ui-polish/03.1-02-SUMMARY.md`
</output>
