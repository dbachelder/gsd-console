---
phase: 07-gsd-ralph-loop-command-queue
plan: 01
type: execute
wave: 1
depends_on: []
files_modified: [src/lib/types.ts, src/hooks/useWorkQueue.ts]
autonomous: true

must_haves:
  truths:
    - "Queue maintains list of commands with status tracking"
    - "User can add commands to queue via add() action"
    - "User can remove commands from queue via remove() action"
    - "Queue status updates through reducer actions"
  artifacts:
    - path: "src/lib/types.ts"
      provides: "QueuedCommand type definition"
      contains: "export interface QueuedCommand"
    - path: "src/hooks/useWorkQueue.ts"
      provides: "useWorkQueue hook with reducer"
      exports: ["useWorkQueue"]
  key_links:
    - from: "src/hooks/useWorkQueue.ts"
      to: "src/lib/types.ts"
      via: "import QueuedCommand"
      pattern: "import.*QueuedCommand.*from.*types"
---

<objective>
Create useWorkQueue hook with useReducer for managing GSD command queue state.

Purpose: Establish centralized queue state management following React's recommended useReducer pattern for complex state with multiple update operations (add, remove, status updates).
Output: useWorkQueue hook with reducer actions and queue state management.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-gsd-ralph-loop-command-queue/07-CONTEXT.md
@.planning/phases/07-gsd-ralph-loop-command-queue/07-RESEARCH.md
@src/lib/types.ts
@src/hooks/useBackgroundJobs.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add QueuedCommand type to types.ts</name>
  <files>src/lib/types.ts</files>
  <action>
    Add QueuedCommand interface after BackgroundJob interface (line ~88):

    ```typescript
    /** Work Queue command status */
    export type QueuedCommandStatus = 'pending' | 'running' | 'complete' | 'failed';

    /** A queued command in the user-managed work queue */
    export interface QueuedCommand {
      id: string;
      command: string;
      args?: string;
      status: QueuedCommandStatus;
      queuedAt: number;
      startedAt?: number;
      completedAt?: number;
      error?: string;
    }
    ```

    Export QueuedCommandStatus and QueuedCommand. Place before ExecutionMode type.
  </action>
  <verify>grep "export interface QueuedCommand" src/lib/types.ts && grep "export type QueuedCommandStatus" src/lib/types.ts</verify>
  <done>QueuedCommand and QueuedCommandStatus types exported from types.ts</done>
</task>

<task type="auto">
  <name>Task 2: Create useWorkQueue hook with reducer</name>
  <files>src/hooks/useWorkQueue.ts</files>
  <action>
    Create new src/hooks/useWorkQueue.ts with useReducer pattern from RESEARCH.md:

    ```typescript
    /**
     * useWorkQueue Hook
     * Manages user-managed GSD command queue for sequential execution.
     * Queue lives only in session memory (no persistence).
     */

    import { useReducer, useCallback } from 'react';
    import type { QueuedCommand } from '../lib/types.ts';

    export type QueueAction =
      | { type: 'add'; command: string; args?: string }
      | { type: 'remove'; id: string }
      | { type: 'updateStatus'; id: string; status: QueuedCommand['status']; error?: string }
      | { type: 'start' }
      | { type: 'clear' };

    /** Generate unique ID for queued command */
    function generateId(): string {
      return `queue-${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;
    }

    function queueReducer(state: QueuedCommand[], action: QueueAction): QueuedCommand[] {
      switch (action.type) {
        case 'add': {
          return [...state, {
            id: generateId(),
            command: action.command,
            args: action.args,
            status: 'pending',
            queuedAt: Date.now(),
          }];
        }
        case 'remove': {
          return state.filter(cmd => cmd.id !== action.id);
        }
        case 'updateStatus': {
          return state.map(cmd =>
            cmd.id === action.id
              ? {
                  ...cmd,
                  status: action.status,
                  error: action.error,
                  ...(action.status === 'running' && { startedAt: Date.now() }),
                  ...(action.status === 'complete' || action.status === 'failed' ? { completedAt: Date.now() } : {}),
                }
              : cmd
          );
        }
        case 'start': {
          // Mark first pending command as running
          return state.map(cmd =>
            cmd.status === 'pending' && state.indexOf(cmd) === 0
              ? { ...cmd, status: 'running', startedAt: Date.now() }
              : cmd
          );
        }
        case 'clear': {
          return [];
        }
        default:
          return state;
      }
    }

    export function useWorkQueue() {
      const [queue, dispatch] = useReducer(queueReducer, []);

      const add = useCallback((command: string, args?: string) => {
        dispatch({ type: 'add', command, args });
      }, []);

      const remove = useCallback((id: string) => {
        dispatch({ type: 'remove', id });
      }, []);

      const updateStatus = useCallback((id: string, status: QueuedCommand['status'], error?: string) => {
        dispatch({ type: 'updateStatus', id, status, error });
      }, []);

      const start = useCallback(() => {
        dispatch({ type: 'start' });
      }, []);

      const clear = useCallback(() => {
        dispatch({ type: 'clear' });
      }, []);

      return {
        queue,
        add,
        remove,
        updateStatus,
        start,
        clear,
      };
    }

    export default useWorkQueue;
    ```

    Use useReducer pattern (NOT multiple useState) per RESEARCH.md recommendation for complex state.
  </action>
  <verify>grep "useReducer" src/hooks/useWorkQueue.ts && grep "export function useWorkQueue" src/hooks/useWorkQueue.ts</verify>
  <done>useWorkQueue hook created with reducer actions (add, remove, updateStatus, start, clear)</done>
</task>

</tasks>

<verification>
- useWorkQueue hook uses useReducer (not multiple useState)
- All reducer actions defined (add, remove, updateStatus, start, clear)
- QueuedCommand type imported and used correctly
- Hook returns { queue, add, remove, updateStatus, start, clear }
</verification>

<success_criteria>
- Queue state managed centrally with useReducer
- Add, remove, status update, start, clear actions work correctly
- Queue is session-only (no persistence code)
</success_criteria>

<output>
After completion, create `.planning/phases/07-gsd-ralph-loop-command-queue/07-01-SUMMARY.md`
</output>
