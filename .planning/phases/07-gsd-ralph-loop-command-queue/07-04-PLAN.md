---
phase: 07-gsd-ralph-loop-command-queue
plan: 04
type: execute
wave: 3
depends_on: [07-01, 07-02, 07-03]
files_modified:
  - src/hooks/useTabNav.ts
  - src/components/layout/TabLayout.tsx
  - src/App.tsx
autonomous: true
gap_closure: true

must_haves:
  truths:
    - "When commands are queued, press 'w' anywhere to open Work Queue tab and view the queue"
    - "In Roadmap or Phase tabs, press 'w' to add plan-phase command for the selected phase to the queue"
  artifacts:
    - path: "src/hooks/useTabNav.ts"
      provides: "Optional activeTab prop for controlled mode"
      contains: "activeTab?: T"
    - path: "src/components/layout/TabLayout.tsx"
      provides: "Controlled activeTab prop from App"
      contains: "activeTab?: TabId"
    - path: "src/App.tsx"
      provides: "Reordered 'w' key handler conditions"
      contains: "if (activeTab === 'roadmap') { ... } else if (workQueue.queue.length > 0)"
  key_links:
    - from: "src/App.tsx"
      to: "src/components/layout/TabLayout.tsx"
      via: "activeTab prop"
      pattern: "activeTab={activeTab}"
---

<objective>
Fix 'w' key handler issues: (1) Tab state synchronization - App's activeTab doesn't control TabLayout, and (2) Condition order - checking queue length before tab type prevents adding multiple commands.

Purpose: Make 'w' key work correctly by unifying tab state control and fixing condition priority
Output: Controlled tab state with 'w' key that adds multiple commands and opens queue tab properly
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/phases/07-gsd-ralph-loop-command-queue/07-UAT.md
@.planning/STATE.md

# Root causes from UAT gaps:
# Gap 1: App's activeTab state (line 125) doesn't control TabLayout rendering (useTabNav at line 71)
# Gap 2: 'w' key handler checks queue.length > 0 BEFORE checking tab type, preventing multiple adds
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add controlled mode to useTabNav hook</name>
  <files>src/hooks/useTabNav.ts</files>
  <action>
Add optional `activeTab?: T` prop to TabNavConfig interface to support controlled mode.

1. In TabNavConfig interface, add:
   - `activeTab?: T` - External active tab for controlled mode

2. Modify useTabNav function to accept controlled mode:
   - If `activeTab` is provided, use it instead of internal state
   - Keep internal state for backwards compatibility (uncontrolled mode)
   - Add useEffect to sync internal state when external activeTab changes

Implementation pattern:
```typescript
export interface TabNavConfig<T extends string> {
  tabs: T[];
  initialTab?: T;
  isActive: boolean;
  onTabChange?: (tab: T) => void;
  activeTab?: T; // NEW: For controlled mode
}

export function useTabNav<T extends string>(config: TabNavConfig<T>): TabNavState<T> {
  const { tabs, initialTab, isActive, onTabChange, activeTab: externalActiveTab } = config;

  const defaultTab = initialTab ?? tabs[0];
  if (!defaultTab) {
    throw new Error('useTabNav: tabs array must not be empty');
  }

  // Internal state (used when externalActiveTab is not provided)
  const [internalActiveTab, setActiveTabState] = useState<T>(defaultTab);

  // Use external activeTab if provided, otherwise use internal state
  const activeTab = externalActiveTab ?? internalActiveTab;

  // Sync internal state when external activeTab changes (for controlled mode)
  useEffect(() => {
    if (externalActiveTab !== undefined) {
      setActiveTabState(externalActiveTab);
    }
  }, [externalActiveTab]);

  // ... rest of hook implementation unchanged
}
```

This maintains backwards compatibility (uncontrolled mode still works) while adding controlled mode capability.
</action>
  <verify>
bun run typecheck passes (verifies TypeScript types are correct)
</verify>
  <done>useTabNav now accepts optional activeTab prop for controlled mode while maintaining uncontrolled mode backwards compatibility</done>
</task>

<task type="auto">
  <name>Task 2: Make TabLayout controlled by App</name>
  <files>src/components/layout/TabLayout.tsx</files>
  <action>
Make TabLayout controlled by adding optional activeTab prop and passing it to useTabNav.

1. Add optional `activeTab?: TabId` prop to TabLayoutProps interface.

2. Pass `activeTab` prop to useTabNav:
   - Update useTabNav call to include `activeTab: activeTab`
   - This makes TabLayout's tab state controlled when App provides the prop

3. Update activeTab to use controlled value throughout TabLayout:
   - Remove duplicate local activeTab variable if it exists
   - Use the activeTab from useTabNav (which now respects the prop)

The change at the useTabNav call site (around line 71):
```typescript
const { activeTab, setActiveTab } = useTabNav<TabId>({
  tabs: ['roadmap', 'phase', 'todos', 'background', 'workqueue'],
  initialTab: flags.only ?? 'roadmap',
  isActive: isActive && !isOnlyMode,
  activeTab: activeTab, // NEW: Propagate App's controlled state
});
```

All other uses of activeTab in TabLayout will automatically use the controlled value from useTabNav.
</action>
  <verify>
bun run typecheck passes (verifies prop types are correct)
</verify>
  <done>TabLayout now accepts optional activeTab prop for controlled mode, unifying tab state with App</done>
</task>

<task type="auto">
  <name>Task 3: Pass activeTab to TabLayout and fix 'w' handler</name>
  <files>src/App.tsx</files>
  <action>
1. Pass activeTab prop to TabLayout component:
   - Add `activeTab={activeTab}` to TabLayout props (around line 382)

2. Fix 'w' key handler condition order (lines 309-332):
   - Reorder conditions to check `activeTab === 'roadmap' | 'phase'` BEFORE `workQueue.queue.length > 0`
   - This allows adding multiple commands from roadmap/phase tabs

Correct condition order:
```typescript
if (input === 'w') {
  // Check tab type FIRST (allows adding multiple commands)
  if (activeTab === 'roadmap' && selectedPhaseNumber) {
    // In Roadmap: add plan-phase command for current phase
    const command = 'plan-phase';
    const args = String(selectedPhaseNumber);
    workQueue.add(command, args);
    showToast(`Added: ${command} ${args}`, 'success');
    setActiveTab('workqueue');
  } else if (activeTab === 'phase' && selectedPhaseNumber) {
    // In Phase: add plan-phase command for current phase
    const command = 'plan-phase';
    const args = String(selectedPhaseNumber);
    workQueue.add(command, args);
    showToast(`Added: ${command} ${args}`, 'success');
    setActiveTab('workqueue');
  } else if (workQueue.queue.length > 0) {
    // Open WorkQueue tab if commands are queued (fallback for non-phase tabs)
    setActiveTab('workqueue');
    showToast(`WorkQueue: ${workQueue.queue.length} commands`, 'info');
  } else {
    showToast('No phase selected or queue empty', 'warning');
  }
}
```

This fixes both issues:
- activeTab prop makes TabLayout controlled by App (solves Gap 1)
- Condition order allows adding multiple commands (solves Gap 2)
</action>
  <verify>
bun run typecheck passes
</verify>
  <done>'w' key correctly opens WorkQueue tab (controlled state) and adds multiple commands from roadmap/phase tabs (correct condition order)</done>
</task>

</tasks>

<verification>
Overall verification:
- [ ] Press 'w' in WorkQueue tab (with queued commands) - shows "WorkQueue: X commands" toast
- [ ] Press 'w' in Roadmap tab (with phase selected) - adds command to queue, opens WorkQueue tab
- [ ] Press 'w' again in Roadmap tab (different phase) - adds another command to queue
- [ ] WorkQueue tab shows all queued commands (multiple items visible)
- [ ] Press 'w' in WorkQueue tab - remains in WorkQueue, shows toast
</verification>

<success_criteria>
1. Tab state is controlled by App (activeTab prop flows to TabLayout)
2. 'w' key in WorkQueue shows toast when commands are queued
3. 'w' key in Roadmap/Phase adds plan-phase command for selected phase
4. Multiple 'w' presses add multiple commands to queue
5. Queue displays multiple items correctly in WorkQueue view
</success_criteria>

<output>
After completion, create `.planning/phases/07-gsd-ralph-loop-command-queue/07-04-SUMMARY.md`
</output>
